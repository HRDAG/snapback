Why snapback not rsnapshot or rsync-snapshot (or dirvish):

   Supports many USB disk/flash drives (plugged in and off-site): efficiently
      runs simultaneous backups (system of cheap USB drives is reliable through
      redundancy); separate logs & policies for each flexibly-named drive ...
   Every config variable can have a per-drive value, in-line or separate-file
      (can use smaller drives (e.g. flash memory) to backup subset of system).
   When an off-site drive is returned and plugged in, missing snapshots are
     copied from all other drives (with minimal impact on regular backups).
   Integrated with 'snapcrypt', for easy use of encrypted, named drives.
   Easy control over backup frequency (& can exclude list of off-peak hours).
   Snapshots named by date (similar to rsync-snapshot), for transparency.
   Sophisticated pruning of old snapshots: different retention policy over the
     hours vs days vs months vs years (high -T debug_level shows how it works).
   Prune/copy & backup simultaneously (separate nice/ionice): never miss backup
      (no seek penalty with SSDs; can optionally suspend prune on disk drives);
      when FS usage threshold is exceeded, pruning gets the higher priority.
   Manages rsync's "Too many links" error (admin solves by adjusting pruning);
     such errors are emailed to (per-drive) sysadmin(s).
   Built-in statistical tool to optimize filesystem inode-size and block-size.
   Has 'watch' action, a dashboard (or 'w' to see everything).
   Can safely and easily kill any backup, prune, copy job, e.g. to eject drive.
   Maintains history of snapshots on each ejected drive (for offsite requests).
   Built-in regression tests to ensure reliable development.
   Written in bash ...

Why write such a serious program in bash:

   Language efficiency is irrelevant, all the time is spent in 'rsync' & 'rm.
   Bash has needed features: lists, regular arrays, associative arrays, regex.
   Simple support of background processes with control of session groups.
   Config file holds shell commands (eg functions, arrays, maps, computation).
   Automagically maintain list of config variables:
      easy/reliable validation that all config variables were set;
      per-variable customization (associative array maps drive name to value).
   Supports simulation, which allows trivial creation of fast regression tests.
   Supports tracing of all commands, for deep debugging, or learning new code.
   Supports sophisticated logging, and printing a call stack on error.
   Can start as a simple script, and evolve into a reliable, featureful one
      (with regression-testing after each change).
