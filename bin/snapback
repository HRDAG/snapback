#! /usr/bin/env bash

version=10			# has to match version= in configure.sh.sample

readonly coder=sweikart@gmail.com

[[ ${1-} == -s ]] && { shift; sample_suffix=.sample; } || sample_suffix=

# libsnap.sh has these funcs/vars: tmp_dir, our_name, our_path, true, false,
# have_cmd, need_cmds, is_darwin, set_FS_type___from_path,
# set__inode_size__data_block_size__dir_block_size___from_path,
# FS_label, set_FS_label___from_FS_device, label_drive,
# set_FS_device___from_FS_label, FS_device,
# set_FS_device___from_path, set_mount_dir___from_FS_device,
# set_mount_dir___from_FS_label,  set_FS_label___from_mount_dir,
# warn, abort, echoE, echoEV, Trace, TraceV, suspend_tracing, restore_tracing,
# log, file_for_logging, log_level, log_msg_prefix, header,
# cd_ , add_words, confirm, is_arg1_in_arg2
#
# search for '####' in libsnap.sh to see environment and coding conventions
source libsnap.sh || exit 1


for dir in /usr/local/etc /etc; do [[ -d $dir/$our_name ]] && break; done
readonly   config_dir=$dir/$our_name
readonly exclude_file=$config_dir/exclude.txt$sample_suffix
readonly  config_file=$config_dir/configure.sh$sample_suffix
readonly  config_file_sample=${config_file%.sample}.sample

[[ -s $config_file_sample ]] ||
   abort "have to install $config_file_sample"

# for each config var, create associative array for per-drive customization
readonly uncustomizable_config_vars="
		drive_dir_prefix old_crypt_name_prefixes drive_config_file"
readonly config_vars=$(sed '/() *{/,/^}/d' $config_file_sample |
		       sed -n -r 's/^[^#=]*\b(\w+)=.*$/\1/p' | sort -u)
for var in $config_vars; do eval "declare -A drv_name2$var"; done
#
# this grabs variables that control backup and pruning, and may also hold
# customizable functions set_drive_name & source_drive_specific_config_file
source $config_file || abort "$config_file broken"

[[ -s $exclude_file ]] ||
   abort "install/edit $exclude_file, see included .sample"

Usage="
Usage: $our_name action [args]
  Current actions are:
    list-drives: list all the mounted backup drives or partitions
    run-backups  [dir(s)]: dir(s) defaults to every mounted backup drive
    prune-drives [dir(s)]: dir(s) defaults to every "" "" ""; see configure.sh
    copy-snapshots src(s) name: copy src(s) to 'name' mounted backup drive

    snapshot-size dir: size of non-hard-linked files (ie in no other snapshots)
    w: show pruning & backup activity, and the status of pruning and backups
    watch [-f][-C][-N names] [watch opts]: 'watch w' (-f: wide; -C: cron jobs)

    # -sig in kill-* defaults to -KILL (-9), i.e. terminates job & deletes lock
    kill-backup [-sig] name(s): for each name (can be 'all'), kill backup job
    kill-prune  [-sig] name(s): for each name (can be 'all'), kill prune job
    kill-both   [-sig] name(s): for each name (can be 'all'), kill both jobs

    add-extN-journal drive_name [FS_device [VG_name]]: fast external journal
    dir-sizes [-f [file] | name]: stats for 'mkfs'; -f -> list/use old data
    mkfs [mkfs-opts] device [name]: prepare first/smallest drive (see comments)
    copy-drive {src_name | ''} dst_name dst_dev: copy (default oldest) to dst

    mk-Z [date [period]]: create mostly-empty snapshot dirs in Z mount-point
    test-prune: use mk-Z to run pruning regression test in the Z pseudo-drive

  NOTE: to see what an action would do, use -d option to simulate the action.

  Common options:
	-C: we are being run from cron

	-c: pass -c (--checksum) to rsync (for actions that use 'rsv')
	-n: pass -n (--dry-run ) to rsync (for actions that use 'rsv')
	-v: pass -v (--verbose ) to rsync and maybe other commands
	-q: pass -q (--quiet   ) to rsync and maybe other commands

	-d: Debug shell script (don't run commands, just show them): simulation
	-t: Trace shell script (show commands as they execute)
	-T level: control whether Trace and TraceV functions run echoE*
"

is_cron=$false   cron_opt=
IfRun= Trace=    debug_opt= trace_opt=  our_rsync_opts=
our_opts=
while getopts "C cnvq dtT: hk"  arg
    do	add_words our_opts -$arg ${OPTARG-}
	case $arg in
	   ( C ) is_cron=$true	cron_opt=-C ;;

	   ( c ) add_words our_rsync_opts --checksum ;;
	   ( n ) add_words our_rsync_opts --verbose --dry-run ;;
	   ( v ) add_words our_rsync_opts --verbose ;;
	   ( q ) add_words our_rsync_opts --quiet   ;; # cancels --verbose

	   ( d ) IfRun="echo -e" debug_opt=-d ;; # $IfRun prevents side-effects
	   ( t ) Trace="set -x"  trace_opt=-t ;;
	   ( T ) Trace_level=$OPTARG Trace_level_opt="-T $OPTARG" ;;

	   (h|k) print_or_egrep_Usage_then_exit "$@" ;;
	   ( * ) abort "$Usage" ;;
	esac
done
let OPTIND=$OPTIND-1
shift $OPTIND
unset arg

[[ -n $Trace && -n $IfRun ]] && IfRun=:

trap '' HUP TERM
trap 'set +x; rm -f $tmp_1 $tmp_2 $tmp_3 $tmp_4 $tmp_5; trap EXIT' EXIT

readonly tmp_1=$tmp_dir/$our_name-1-$BASHPID	; tmp=$tmp_1
readonly tmp_2=$tmp_dir/$our_name-2-$BASHPID
readonly tmp_3=$tmp_dir/$our_name-3-$BASHPID
readonly tmp_4=$tmp_dir/$our_name-4-$BASHPID
readonly tmp_5=$tmp_dir/$our_name-5-$BASHPID

need_cmds lockpid

shopt -s extglob

umask 02				# log dirs are setgid sudo

set -u					# abort if access unset variable

FUNCNEST=100				# catch coding errors

head -n1 $config_file_sample | fgrep -q -x "# version=$version" ||
  $IfRun abort "$config_file_sample version does not match $our_name"

# $Trace

##############################################################################
# Miscellaneous variables used by for making and pruning backup snapshots.
##############################################################################

# touched when prune ends; its time is compared to files in $config_dir/
readonly pruned_timestamp=.pruned.ts

readonly our_opts=${our_opts# }
# need to fork and exec ourselves for session control with 'setsid'
readonly prune_drive_exe="$our_path $our_opts prune-drive"
readonly  run_backup_exe="$our_path $our_opts run-backup"

readonly hostname=${HOSTNAME%%.*}

readonly log_dir=/var/log/$our_name

file_for_logging=$log_dir/messages.log	     # set__drive_dir__* sets it
log_msg_prefix=' ${action-} ${drive_name-}' # this gets eval'ed each time

##############################################################################
# Miscellaneous functions used by for making and pruning backup snapshots.
##############################################################################

set_readable_du_size() {
	declare -i size=$1

	local suffix=K
	while (( $size >= 1024 ))
	   do	let size/=1024
		case $suffix in		# see: man du
		    ( 'K' ) suffix=M ;;
		    ( 'M' ) suffix=G ;;
		    ( 'G' ) suffix=T ;;
		    ( 'T' ) suffix=P ;;
		    ( 'P' ) suffix=E ;;
		    ( 'E' ) suffix=Z ;;
		    ( 'Z' ) suffix=Y ;;
		esac
	done
	readable_du_size=$size${suffix}B
}

##############################################################################
# process and lock management
##############################################################################

set_PGID() {

	if [[ $# == 0 ]]
	   then PGID=
	   else PGID=$(set -- $(ps h -o pgid $* | sort -u); echo $*)
	fi
	[[ $PGID ]]
}

# ---------------------------------

process_group_PIDs() {

	local PGID
	for PGID
	    do	# I don't know why this didn't work
		# ps -u root -o pid,pgid | grep " $PGID$" | awk '{ print $1 }'

		# "pstree -p -a" lines start with: <command>,<PID> ...
		pstree -p -a $PGID | sed 's/^[^,]*,\([0-9]*\).*/\1/'
	done
}

# ----------------------------------------------------------------------------

readonly lock_types="prune-drive run-backup"

readonly lock_dir=/var/lock/$our_name

lock_file=

set_lock_file() {
	local type=$1 name=${2:-$drive_name}

	[[ -d $lock_dir ]] || sudo mkdir -p --mode=1777 $lock_dir

	is_arg1_in_arg2 $type $lock_types || abort "lock: '$type' is unknown"
	set_drive_name $name
	lock_file=$lock_dir/$type-$drive_name.pid
}

# ---------------------------------

run_lockpid() {
	local lock_file=$1 lock_holder_action=$2

	local our_PID=$BASHPID
	local lock_cmd="lockpid $lock_file $our_PID"
	lockpid_output=$($IfRun $lock_cmd 2>&1)
	local status=$?

	if [[ $status == 0 ]]
	   then [[ $IfRun ]] &&
		echo "$lockpid_output" | sed "s@ $our_PID@ <our_PID>@"
		return 0
	fi

	local lock_holder_PID=$(echo "$lockpid_output" |
				sed 's@^Process @@; s@ holds lock .*@@')
	if [[ $status == 1 && $lock_holder_PID ]]
	   then [[ ! $is_cron || $(date '+%H') == 00 || $log_level -gt 0 ]] &&
		log  "process $lock_holder_PID is $lock_holder_action"
	   else log "$lock_cmd -> $lockpid_output (status=$status)"
	fi >&2
	return 1
}

# -----------------------------------------------------------

locker_PIDs() {
	local type=$1; shift
	[[ $* == all ]] && set -- $(list_drives)

	local name
	for name
	    do	set_lock_file $type $name
		if lockpid $lock_file >& /dev/null
		   then lockpid -r $lock_file
		   else echo $(< $lock_file)
		fi
	done
}

# ---------------------------------

kill_locker_group() {
	local type=$1; shift
	[[ $1 == -*  ]] && { local signal=${1^^}; shift; } ||local signal=-KILL
	[[ $* == all ]] && set -- $(list_drives)

	set_signal_is_kill $signal
	local PGID pgid status=1
	set_PGID $(locker_PIDs $type $*)
	[[ $is_regression_test ]] && local sudo= || local sudo=sudo
	for pgid in $PGID
	    do	$IfRun $sudo kill $signal -$pgid && status=0 || continue
		[[ $signal_is_kill ]] && $IfRun $sudo lockpid -r $lock_file
	done

	return $status
}

# -------------------------------------------------------

# you don't generally need this: instead, use negative lock pid to run ps
# on a job, and use signal_job for signaling
job_PIDs() {
	local type=$1; shift

	process_group_PIDs $(locker_PIDs $type $*)
}

# ---------------------------------

signal_is_kill=

set_signal_is_kill() {
	local signal=${1#-}

	case ${signal^^} in
	   ( SIGKILL | KILL | 9 )
		signal_is_kill=$true  ; return 0 ;;
	   ( *)	signal_is_kill=$false ; return 1 ;;
	esac
}

# ----------------------

signal_job() {
	local signal=${1#-} type=$2 name=${3:-$drive_name}

	[[ $is_regression_test ]] && local sudo= || local sudo=sudo

	local lock_file
	set_lock_file $type $name &&
	[[ -s $lock_file ]] &&
	set -- $(< $lock_file) &&
	[[ $# != 0 ]] &&
	$IfRun $sudo kill -s ${signal^^} -$1 &> /dev/null || return 1
	set_signal_is_kill    $signal &&
	$IfRun $sudo lockpid -r $lock_file
}

##############################################################################
# miscellaneous
##############################################################################

list_drives() {

	suspend_tracing
	customize_and_validate_configuration_variables Z # ensure have *pattern

	if [[ -t 0 || -t 1 || -t 2 ]]
	   then local regex=$anchored_drive_UI_name_regex
	   else local regex=$anchored_drive_name_regex # for cron (& nohup)
	fi
	df --output=target --no-sync |
	   grep "^$drive_dir_prefix$regex$" | sort -u
	restore_tracing
}

# ---------------------------------

is_drive_mounted() {
	local drive_dir=$1

	[[ $drive_dir ]] || return 1
	df | grep -q " $drive_dir$" || [[ $drive_dir == *[-/]Z ]]
}

# -----------------------------------------------------------------------------

function fix_snapshot_names {
	local drive_dir=$1

	set -- $drive_dir/$old_snapshot_pattern*
	[[ -d $1 ]] || return 0

	# this --kill -9 is completely safe
	$IfRun sudo fuser -k -9 -M $drive_dir
	local msg="$old_snapshot_pattern to $snapshot_pattern"
	log "renaming snapshots from $msg, first waiting ..."
	$IfRun sleep 5			# wait for kill

	local old_name
	cd_ $drive_dir
	for old_name in $old_snapshot_pattern*
	    do	[[ -d $old_name ]] || continue
		set_new_name $old_name
		$IfRun sudo mv $old_name $new_name || abort "need sudo privs"
	done
}

# ----------------------------------------------------------------------------

set_oldest_snapshot() {

	local oldest= FS
	for FS in $(list_drives)
	    do	suspend_tracing
		set -- $FS/$snapshot_pattern
		restore_tracing
		[[ $oldest && $(basename $oldest) < $(basename $1) ]] &&
		   continue
		oldest=$1
	done
	[[ -d $oldest ]] || abort "no old backup drives are mounted"
	oldest_snapshot=$oldest
}

##############################################################################-
# Setup variables for working with a specific backup drive.
##############################################################################-

drive_log_dir=

admin_group=

is_regression_test=$false

# this is normally called by set_drive_name; but you can pass
# a null drive_name to set default file_for_logging & drive_log_dir
set__drive_log_dir__file_for_logging__admin_group__is_regression_test() {
	local  drive_name=${1-}	     # called from set_drive_name, so $1 valid

	if [[ $drive_name ]]
	   then drive_log_dir=$log_dir/$drive_name
	   else drive_log_dir=$log_dir
	fi
	TraceV 3 drive_log_dir
	file_for_logging=$drive_log_dir/messages.log

	suspend_tracing
	local group
	for group in sudo wheel admin adm NoNe '' # 'admin' is Darwin / MacOS
	    do	is_arg1_in_arg2 $group $(id -G -n $LOGNAME) && break
	done
	[[ $group == NoNe ]] && group= || admin_group=$group
	restore_tracing group

	[[ -d $log_dir ]] || {
	sudo mkdir -p	   $log_dir	; [[ $group ]] &&
	sudo chgrp $group  $log_dir &&
	sudo chmod g+w,g+s $log_dir
	}
	[[ -d $log_dir ]] || abort "need sudo privs for initial setup"

	[[ $drive_name == Z ]] && is_regression_test=$true

	[[ $group ]] && group=:$group
	if [[ ! -d $drive_log_dir ]]
	   then sudo mkdir -p -m g+w,o-w $drive_log_dir
		[[ $is_regression_test ]] &&
		sudo touch $file_for_logging &&
		sudo chown $LOGNAME$group $drive_log_dir $file_for_logging
	fi
	[[ -d $drive_log_dir ]] || abort "need sudo privs to setup new drive"

	suspend_tracing
	customize_and_validate_configuration_variables $drive_name
	restore_tracing

	return 0
}

# ---------------------------------

drive_config_file=

have_cmd \
source_drive_specific_config_file ||  # configure.sh can replace this function
source_drive_specific_config_file() {
	[[ $# == 0 ]] && return
	local _name=$1  _main_config_file=${2:-${config_file-}}
	set_drive_name $_name
	[[ $_main_config_file ]] || abort "pass config_file as 2nd arg"

	local     _config_file=${_main_config_file/%.sh/-$drive_name.sh}
	if [[ -s $_config_file ]]
	   then drive_config_file=$_config_file	; source $_config_file
	   else drive_config_file=		; true
	fi
}

# ---------------------------------

drive_name=				# global, used by log()

have_cmd \
set_drive_name ||		      # configure.sh can replace this function
set_drive_name() {
	[[ $# == 1 && $1 ]] || abort "set_drive_name takes a single argument"

	local name=$1

	if [[ ! $name =~ ^$anchored_drive_UI_name_regex$ ]]
	   then if [[ $name == /dev/* ]]
		   then set_FS_label___from_FS_device $name
			set_mount_dir___from_FS_label $FS_label
			drive_dir=$mount_dir
		elif [[ $name != /* ]]
		   then set_mount_dir___from_FS_label $name
			drive_dir=$mount_dir
		   else drive_dir=$name
		fi
		[[  $drive_dir =~					\
		   ^$drive_dir_prefix$anchored_drive_UI_name_regex$ ]] ||
		   abort "$name is not drive-dir or FS-label or valid-name"
		name=${drive_dir#$drive_dir_prefix}
	fi
	if [[ $is_drive_name_capitalized ]]
	   then drive_name=${name^}
	   else drive_name=$name
	fi
	TraceV 3 drive_name

       set__drive_log_dir__file_for_logging__admin_group__is_regression_test \
	   $drive_name
}

# ---------------------------------

drive_dir=				# global, just in case

is_OK_if_drive_dir_unmounted=$false

set_drive_dir() {
	local drive_name=$1		# result of set_drive_name, i.e. valid

	[[ $drive_name != */* ]] ||
	  abort "'/' in drive name not (yet)supported, add to drive_dir_prefix"

	drive_dir=$drive_dir_prefix$drive_name

	if [[ $is_regression_test && ! -d $drive_dir ]]
	   then	[[ $admin_group ]] && local group=:$admin_group || local group=
		sudo mkdir $drive_dir &&
		sudo chmod g+s,g+w $drive_dir &&
		sudo chown $LOGNAME$group $drive_dir ||
		  abort "need sudo privs to setup pseudo-drive 'Z' for testing"
	fi

	if  is_drive_mounted  $drive_dir
	   then fix_snapshot_names $drive_dir # must call last
	   else [[ $is_OK_if_drive_dir_unmounted ]] ||
		    warn "no filesystem mounted on $drive_dir" ||
		    : print_call_stack
		return 1
	fi
}

# -----------------------------------------------------------------------------

customize_config_variables() {
	local name=${1-}

	[[ $name ]] || return

	set_drive_name $name ||
	   abort "$config_file needs set_drive_name function"

	[[ $drive_name == Z ]] && is_regression_test=$true

	local var_name
	for var_name in $config_vars
	    do	local array_name=drv_name2$var_name
		eval "local drv_names=\${!$array_name[*]}"
		is_arg1_in_arg2 $drive_name $drv_names || continue

		eval "local custom_value=\${$array_name[\$drive_name]-}"
		is_arg1_in_arg2 $var_name $uncustomizable_config_vars &&
		   abort "$config_file can't have custom '$var_name'"
		eval "$var_name=\$custom_value"
		set +x
		Trace 2 "$array_name[$drive_name] -> $var_name=$custom_value"
	done
}

# ------------------------------------------------------------------

validate_config_variables() {

	declare -p $config_vars | grep -v '^declare -'
	[[ ${PIPESTATUS[0]} == 0 ]] ||
	    abort "must assign above variables, see $config_file_sample"

	local var=snapshot_date_time_separator
	[[ ${!var} == ',' ]] ||
	   abort "$var is not implemented, email $coder"
	#
	local var=extra_includes
	[[ ! ${!var} ]] ||
	   abort "$var is not implemented, email $coder"
	#
	local bad_punctuation="[-.:0-9]" # you could ask $coder to change this
	[[ $snapshot_date_time_separator != *$bad_punctuation* ]] ||
	   abort "snapshot_date_time_separator can't contain $bad_punctuation"
	#
	[[ $excluded_backup_hours != *[^\ \	0-9]* ]] ||
	   abort "excluded_backup_hours must be list of numbers, no ranges/etc"

	set -- $config_file $drive_config_file

	echo " $dirs_to_backup " | grep ' [^/]' &&
	   abort "dirs_to_backup contains a non-absolute path in $*"

	is_arg1_in_arg2 $backup_period $valid_backup_periods ||
	   abort "invalid 'backup_period=$backup_period' in $*"

	[[ -s $exclude_file ]] ||
	   abort "'exclude_file=$exclude_file' is empty file (from $*)"

	is_arg1_in_arg2 0 $successful_rsync_exit_statuses ||
	   abort "'successful_rsync_exit_statuses=$successful_rsync_exit_statuses' must contain 0 in $*"
}

# ------------------------------------------------------------------

customize_and_validate_configuration_variables() {
	local name=${1-}

	# avoid infinite loop
	set -- ${FUNCNAME[*]} ; shift
	is_arg1_in_arg2 $FUNCNAME $* && return

	suspend_tracing

	type source_drive_specific_config_file &> /dev/null && # optional
	source_drive_specific_config_file $name

	customize_config_variables $name

	validate_config_variables	# must do this last

	restore_tracing
}

##############################################################################
# Manage priorities for backup and prune and update/merge.
##############################################################################

is_disk_usage_too_high() {

	set -- $(df --output=pcent,ipcent $drive_dir | tail -n1)
	declare -i block_percent=${1%\%} inode_percent=${2%\%}
	(( $block_percent <= $min_FS_usage_percent )) || return 0
	(( $inode_percent <= $min_FS_usage_percent )) || return 0
	return 1
}

# -----------------------

setup_merge_priority() {

	[[ $is_regression_test ]] && local sudo= || local sudo=sudo
	$IfRun $sudo $cmd_to_set_merge_CPU_priority $BASHPID &>/dev/null
	$IfRun $sudo $cmd_to_set_merge_IO_priority  $BASHPID &>/dev/null
}

# --------------

setup_lower_priority() {

	[[ $is_regression_test ]] && local sudo= || local sudo=sudo
	$IfRun $sudo $cmd_to_set_lower_CPU_priority $BASHPID &>/dev/null
	$IfRun $sudo $cmd_to_set_lower_IO_priority  $BASHPID &>/dev/null
}

# --------------

setup_higher_priority() {

	[[ $is_regression_test ]] && local sudo= || local sudo=sudo
	$IfRun $sudo $cmd_to_set_higher_CPU_priority $BASHPID &>/dev/null
	$IfRun $sudo $cmd_to_set_higher_IO_priority  $BASHPID &>/dev/null
}

# -----------------------

# returns success if run at higher priority
setup_run_backup_priority() {

	if is_disk_usage_too_high
	   then  setup_lower_priority ; return 1
	   else setup_higher_priority ; return 0
	fi
}

# --------------

setup_prune_drive_priority() {

	if is_disk_usage_too_high
	   then setup_higher_priority
	   else  setup_lower_priority
	fi
}

# ---------------------------------

_backup_management_of_prune() {
	local name=$1 state=$2

	[[ $is_cron ]] || return

	if [[ ( ! $suspend_prune_when_backup && $state ==  pre-rsync ) ||
	      (   $suspend_prune_when_backup && $state == post-rsync ) ]]
	   then $IfRun run_jobs_in_parallel prune $drive_dir
		return
	fi

	[[ $suspend_prune_when_backup && $state == pre-rsync ]] &&
	signal_job SIGSTOP prune-drive $name
}

##############################################################################-
##############################################################################-
# Functions and variables used to prune old backup snapshots.
##############################################################################-
##############################################################################-

_is_time_to_prune_drive() {
	local dir=$1

	[[ ! $is_cron ]] && return 0	# run by a person?

	[[ $(date '+%H') == 00 ]] && return 0 # time for our daily prune?

	set -- $dir/*.rm
	[[ -d $1 ]] && return 0		# have partially-deleted snapshots?

	local pruned_TS=$dir/$pruned_timestamp

	[[ ! -e $pruned_TS ]] && return 0 # never finished a prune?
	[[ $pruned_TS -ot $config_file   ]] && return 0 # newer config?
	[[ $pruned_TS -ot $exclude_file  ]] && return 0 # newer excludes?
	[[ $(find $pruned_TS ! -mtime 0) ]] && return 0	# older prune?

	return 1			# not time to prune
}

# ----------------------

_rm_pruned_snapshots() {
	local snapshots_file=$1

	local snapshot

	suspend_tracing
	set -- $(< $snapshots_file)

	[[ $# != 0 ]] &&
	if (( $log_level >= 2 ))
	   then [[ $IfRun ]] ||
		log "will prune these snapshots: " $*
	   else $IfRun \
		log "pruned $# snapshots, will rename to *.rm for deletion"
	fi

	# first, rename snapshots to be pruned, so can see the pruning backlog
	for snapshot
	    do	[[ $snapshot != *.rm ]] &&
		$IfRun mv $snapshot $snapshot.rm
	done

	set -- *.rm
	[[ -d $1 ]] || shift
	local snapshot_basenames=$*
	restore_tracing

	if [[ ! -d latest ]]
	   then set -- $snapshot_pattern # only the successful snapshots
		[[ -d ${!#} ]] && $IfRun rm -f latest &&
		$IfRun ln -s $(basename ${!#}) latest
	fi

	suspend_tracing
	# put newest ones first, since they have the most hardlinks.
	# use absolute paths, so the 'ps' output is more clear.
	set -- $(echo $drive_dir/*.rm | tr ' ' '\n' | sort -r)
	[[ -d $1 ]] || shift
	local number_pruned_snapshots=$#
	restore_tracing number_pruned_snapshots

	$Trace
	# just prune subdirs containing files with massive # of hard-links;
	# except too-high disk usage is more critical than "Too many files".
	[[ ${hard_link_dirs-} ]] && ! is_disk_usage_too_high $drive_dir &&
	for snapshot
	    do	local subdir
		for subdir in $hard_link_dirs
		    do	$IfRun rm -rf $snapshot$subdir
		done
		[[ $IfRun ]] && set +x
	done

	$Trace
	# finally, prune the rest of the contents of the *.rm snapshots
	for snapshot
	    do	$IfRun rm -rf $snapshot
		[[ $IfRun ]] && set +x
	done

	(( $number_pruned_snapshots > 0 )) &&
	if (( $log_level >= 3 ))
	   then [[ $IfRun ]] ||
	        log "deleted these pruned snapshots: $snapshot_basenames"
	   else $IfRun \
		log "deleted $number_pruned_snapshots *.rm pruned snapshots"
	fi

	local pruned_TS=$drive_dir/$pruned_timestamp
	[[ $drive_name == Z ||		# regression test?
	   ( ! $IfRun &&		# ... too slow for real drive
	     # very slow: only run if exclude.txt changed since our last run
	     ( ! -e $pruned_TS ||
		    $pruned_TS -ot $exclude_file ) ) ]] &&
	{
	# prune exclude-patterns from _all_ snapshots, very slow
	local exclude_pattern file
	for snapshot in $drive_dir/$snapshot_pattern*
	    do	[[ $snapshot == *.rm ]] && continue
		grep '^ */' $exclude_file | fgrep -v '**' |
		while read exclude_pattern
		    do	set -- $snapshot$exclude_pattern
			for file	# can have SPACEs, need to quote it
			   do	[[ -e "$file" ]] && echo "$file"
			done
		done
		[[ $IfRun ]] && set +x
	done | tr '\n' '\0' | xargs -0 -r $IfRun rm -r # -0: files with SPACEs
	}

	$IfRun log "pruned exclude-patterns from _all_ snapshots"

	$IfRun sync --file-system $drive_dir &> /dev/null
}

# ---------------------------------------------------------------------------
# variables and functions that implement the date format in snapshot basename
# ---------------------------------------------------------------------------

# snapshot basename format is Year-Mo-Da,Hr, all implemented in this section;
#    to implement snapshot_date_time_separator, search for: ,00 ,?? ,$ ,/

#			       _Year_MoDa-Hr
readonly old_snapshot_pattern="[1-9]?????-??"
readonly     snapshot_pattern="[1-9][0-9][0-9]?-??-??,??" # Year-Mo-Da,Hr
set_new_name() { new_name=$(echo $1 | sed -r 's/-/,/;s/^(..)(..)/20\1-\2-/'); }
readonly     snapshot_regex=${snapshot_pattern//\?/.}

set_date_time() { date_time=$(date '+%Y-%m-%d,%H'); }
set_day      () {       day=$(date '+%Y-%m-%d' -d "@$1" ); }
set_seconds  () {   seconds=$(date '+%s'       -d "$(basename $1 |
				        sed 's/\..*//;s/,/ /;s/$/:00:00/')" ||
				warn "$FUNCNAME: can't parse $1"; ); }

# --------------------------------------------

shorten_date() {
	case $1 in
	    (  hour ) sed 's/,..$//' ;;	# strip time from snapshot's date-time
	    (   day ) sed 's/-..$//' ;; # strip day from snapshot's date
	    ( month ) sed 's/-..$//' ;; # strip month from year-month
	    (  year ) sed   's/.$//' ;; # turn year into decade
	esac | uniq
}

declare -A type2date_suffix_pattern=(
	 [null]=""
	 [hour]=",??"
	  [day]="-??,??"
	[month]="-??-??,??"
	 [year]="?-??-??,??"
)

set_prune_pattern() {
	local type=$1 pattern=$2  pp

	local date_suffix_pattern=${type2date_suffix_pattern[$type]}
	local prefix_pattern=${snapshot_pattern%$date_suffix_pattern}
	case $type in
	    (  hour ) pp="$prefix_pattern$pattern{.*,}"		 ;;
	    (   day ) pp="$prefix_pattern$pattern,00{.*,}"	 ;;
	    ( month ) pp="$prefix_pattern$pattern-01,00{.*,}"	 ;;
	    (  year ) pp="$prefix_pattern$pattern-01-01,00{.*,}" ;;
	esac
	prune_pattern=$pp
}

readonly valid_backup_periods="1 2 4 8 12 24" # also in configure.sh comment

function load_type_maps {

    type2prune_type_patterns=(
# the ones these patterns skip: hour=00, day=01, month=01, year=00
# period after prune: 2                   4                ~8         ~12   all
   [hour]=",?[13579]         ,{[02][26],1[048]}       ,{04,20}    ,{08,16} ,12"
    [day]="-{?[3579],[1-3]1} -{[02][26],1[048],30} -{04,12,20,28} -{08,24} -16"
  [month]="-{0[3579],11}          -{02,06,10}        -{04,08,12}"
   [year]="  [13579]                 {2,6}              {4,8}"
    )

    type2date_span=(
	 [hour]=$days_per_span_for_hour_prune
	  [day]=$months_per_span_for_day_prune
	[month]=$years_per_span_for_month_prune
	 [year]=$decades_per_span_for_year_prune
    )
}

# ---------------------------------------------------------------------------
# end of variables and functions that implement the date format in snapshots
# ---------------------------------------------------------------------------

scale_date_span() {

	date_span=$( echo "$date_span $pruning_span_scale_factor" |
		     awk '{ printf "%.0f\n", $1 * $2 }' )
}

_oldest_snapshot=

prune_type_to_file() {
	local type=${1%s} file_of_snapshots_to_prune=$2; shift 2
	set -- $(echo $* | tr ' ' '\n' | cut -d. -f1 | shorten_date $type)
	local remaining_reverse_sorted_snapshot_dates=$*

	declare -A type2prune_type_patterns type2date_span
	load_type_maps		# run after call to customize_config_variables
	local date_span=${type2date_span[$type]}
	scale_date_span
	local prune_type_patterns=${type2prune_type_patterns[$type]}
	local date_suffix_pattern=${type2date_suffix_pattern[$type]}
	[[ $type == hour ]] && _oldest_snapshot=$drive_dir/${!#},00

	Trace 5 "\n==> $type prune <=="
	declare -i period=$backup_period
	local     prune_type_pattern  prune_pattern
	while [[ $prune_type_patterns ]]
	    do	set -- $remaining_reverse_sorted_snapshot_dates
		Trace 5 "\nLOOP $type: $# dates left: ${1-} ${2-} ... ${!#}"
		! _do_skip_newest_span_of_days $type || shift $date_span ||
		    shift $# # shift does nothing if try to shift more than $#
		remaining_reverse_sorted_snapshot_dates=$*
		local first_prune_date=${1-}
		[[ $first_prune_date ]] || break

		set -f; set -- $prune_type_patterns; set +f
		prune_type_pattern=$1; shift # we'll use first pattern
		prune_type_patterns=$*	     # save remaining patterns

		set_prune_pattern $type $prune_type_pattern
		TraceV 5 date_suffix_pattern first_prune_date \
			  prune_type_pattern prune_pattern
		eval "set -- $prune_pattern"
		[[ -d $1 ]] || shift
		Trace 5 " Matched  $# snapshots: ${1-} ${2-} ${3-} ... ${!#}"

		# skip over the snapshot prune-matches that aren't old enough
		set -- $(echo $* | tr ' ' '\n' | sort -r)
		while [[ $# != 0 ]]
		   do	[[ $1 == $drive_dir/[^1-9]* ]] && shift && continue
			local day_hour=${1##*/}
			local date=${day_hour%$date_suffix_pattern*}
			[[   $date > $first_prune_date ]] || break
			shift
		done
		[[ -d ${1-} ]] || continue
		# delete all the old-enough prune matches
		Trace 5 "Deleting ~$# snapshots: $1 ${2-} ${3-} ... ${!#}"
		echo ${*%$_oldest_snapshot*} # don't delete oldest snapshot
	done >> $file_of_snapshots_to_prune

	echo $remaining_reverse_sorted_snapshot_dates
}

# ----------------------

_do_skip_newest_span_of_days() {
	local type=$1

	[[ $type != hour* ]] && return 0

	# if $backup_period had been too short and we lengthened it,
	#   we delete recent snapshots that "shouldn't" have been created,
	#   by not shifting remaining-days until we've pruned the "spurious"
	if   (( period <=  1 )) ; then return 0
	elif (( period <=  2 )) ; then period=1
	elif (( period <=  4 )) ; then period=2
	elif (( period <=  8 )) ; then period=4
	elif (( period <= 24 )) ; then period=8
				  else period=24
	fi
	Trace 5 "period now $period, didn't shift"
	return 2			# higher than 'shift' error status
}

# ---------------------------------------------------------

# for goals of this function, see prune-variable comments in configure.sh
prune_drive() {
	local drive_name=$1 drive_dir

	set_drive_name $drive_name
	set_drive_dir  $drive_name || return 1

	_is_time_to_prune_drive $drive_dir || return 0

	[[ $UID == 0 || $is_regression_test ]] || $IfRun abort "run with sudo"

	local lock_file
	set_lock_file prune-drive $drive_name
	run_lockpid $lock_file "pruning $drive_dir" ||
	    # since we're called, lock holder should be un-suspended
	    { signal_job SIGCONT prune-drive $drive_name; return 1; }

	trap '' HUP
	setup_prune_drive_priority

	$Trace
	local  snapshots_to_prune_file=$tmp_4
	rm -f $snapshots_to_prune_file

	cd_ $drive_dir	# so can safely kill job with: fuser -k -M $drive_dir

	# set -- <all the snapshot basenames, reverse sorted>
	suspend_tracing
	set -- $(cd $drive_dir &&
		   echo $snapshot_pattern*  | # '*' for .links & .partial
		   tr ' ' '\n' | sort -u -r |
		   grep -v '\.rm$')	# _rm_pruned_snapshots handles *.rm
	restore_tracing
	# prune_type_to_file returns dates remaining, to check for more pruning
	set -- $(prune_type_to_file hour  $snapshots_to_prune_file $*)
	set -- $(prune_type_to_file day   $snapshots_to_prune_file $*);#$Trace
	set -- $(prune_type_to_file month $snapshots_to_prune_file $*);#set +x
	set -- $(prune_type_to_file year  $snapshots_to_prune_file $*)

	_rm_pruned_snapshots $snapshots_to_prune_file
	rm $snapshots_to_prune_file

	$IfRun touch $drive_dir/$pruned_timestamp # touch even if did nothing

	$IfRun lockpid -r $lock_file
}

##############################################################################-
##############################################################################-
# Functions and variables used to create new backup snapshots.
##############################################################################-
##############################################################################-

_is_time_to_run_backup() {
	local dir=$1

	[[ ! $is_cron ]] && return 0	# run by a person?

	local  current_hour=$(date '+%k')
	local excluded_hours=$(echo ${excluded_backup_hours-} | sed 's/\b0//g')
	is_arg1_in_arg2 $current_hour $excluded_hours && return 1
	(( $current_hour % $backup_period == 0 )) && return 0

	return 1
}

# -------------------------------------------------------

declare -i num_link_dests=0

set_link_dest_opts() {
	local new_snapshot=$1

	suspend_tracing
	# want the .links snapshots too, so quickly recover from
	#    'Too many links' by just copying the file
	# want a .partial to get the latest stuff, but won't "count" it
	set -- $(echo $drive_dir/$snapshot_pattern{,.links,.partial} |
		 tr ' ' '\n' | sort -r)
	restore_tracing

	while [[ ! -d ${1-} || ${1-} == $new_snapshot* ]]
	   do	[[ $# != 0 ]] || return	# we might not have any snapshots
		shift
	done

	# need at least 2 --link-dest args in case the sysadmnin borked one,
	# and a few hours worth in case a file was deleted then recovered;
	# don't make this too large, it slows recovery from "Too many links"
	if (( $backup_period == 1 ))
	   then num_link_dests=4
	   else num_link_dests=2
	fi

	if [[ -d ${1-} ]]
	   then declare -i snapshots_used=0
		suspend_tracing
		for snapshot
		    do	[[ -d $snapshot ]] || continue
			link_dest_opts="$link_dest_opts --link-dest=$snapshot"
			[[ $snapshot != *.partial ]] && snapshots_used+=1
			(( snapshots_used >= num_link_dests )) && break
		done
		restore_tracing link_dest_opts
	fi
}

# -------------------------------------------------------

readonly rsync_time_subdir=stats/rsync-minutes

record_rsync_time() {
	local snapshot=$(basename $1)
	declare -i start_secs=$2

	declare -i end_secs=$(date '+%s')
	declare -i minutes=$(( (30 + $end_secs - $start_secs) / 60 ))

	local file=$drive_log_dir/$rsync_time_subdir/$snapshot.txt
	$IfRun sudo mkdir -p $(dirname $file)

	local cmd="echo $minutes > $file"
	if [[ $IfRun ]]
	   then echo "$cmd"
	   else eval "$cmd"
	fi || return 1

	declare -i days_to_keep=3     # make sure don't just have weekend data
	declare -i number_files_per_day=24/$backup_period
	declare -i number_files_to_keep=$number_files_per_day*$days_to_keep
	eval "set -- $(dirname $file)/$snapshot_pattern.txt"
	while (( $# > $number_files_to_keep ))
	    do	$IfRun rm $1
		shift
	done
}

# -------------------------------------------------------

_links_error_msg() {
	local msg=$*

	# since contents of $() are run in subshell, have to echo results
	declare -i max_src_links=$(
	declare -i max_src_links=0
	bzcat $log | tr -d '"' | cut -d' ' -f3 |
	while read dst_file
	    do	src_file=${dst_file#$drive_dir/$snapshot_pattern.partial}
		[[ -f $src_file ]] || continue
		set -- $(ls -l $src_file)
		((   $max_src_links >= $2 )) && continue
		      max_src_links=$2
		echo $max_src_links
	done | tail -n1
	)

	declare -i link_dest_wait=$(( num_link_dests * backup_period ))
	set -- *.rm
	msg="$msg; Worst case, tried to add $max_src_links links to a snapshot file; these files will eventually appear in a new snapshot after $link_dest_wait hours; $# snapshots waiting to be pruned, newer prunes subtract ~$max_src_links links"

	[[ $hostname != eleanor ]] &&
	msg="$msg; Edit prune variables in $config_file to reduce # snapshots"

	echo "$msg"
}

# ---------------------------------

_handle_rsync_results() {
	local new_snapshot=$1 status=$2 log=$3

	if [[ -s $log ]]
	   then [[ ${is_interactive-$IfRun} ]] && { bzcat $log; rm $log; }
	   else rm $log
	fi

	# uncomment next line to debug link_fail_count code with -d option
	# echo 'link failed: Too many links (31)' | bzip2 >> $log; status=31

	local error_msg=

	if is_arg1_in_arg2 $status "$successful_rsync_exit_statuses"
	   then $IfRun mv  $new_snapshot.partial     $new_snapshot &&
		[[ $new_snapshot != *.links ]] &&
		$IfRun rm -f latest && $IfRun ln -s ${new_snapshot##*/} latest
		record_rsync_time $new_snapshot $start_seconds
		[[ $new_snapshot == *,00 || $log_level -gt 0 ||
		   ! $is_cron || $IfRun ]] &&
		$IfRun log "created $new_snapshot (at ${priority}er priority)"
	   else set -- $(bzcat $log 2>/dev/null | # might be empty file
			 grep -c ': Too many links (31) *$')
		local  link_fail_count=$1 # see test, above
		if (( $link_fail_count == 0 ))
		   then error_msg="rsync exit status=$status"
		   else error_msg="$link_fail_count 'Too many links'"
			error_msg=$(_links_error_msg "$error_msg")
			$IfRun mv $new_snapshot.partial $new_snapshot.links
			record_rsync_time $new_snapshot $start_seconds
		fi
		if is_arg1_in_arg2 $status "$no_log_rsync_exit_statuses" ||
		   (( $(bzcat $log | wc -l) == 0 ))
		   then rm -f $log
			error_msg="$error_msg; Partial snapshot still useful"
		   else error_msg="$error_msg; See $log"
		fi
	fi

	if [[  $error_msg ]]
	   then	[[ $Trace || $drive_name == Z ]] && # Z = debug "drive"
		log "$error_msg" ||
		log "$error_msg" |& tee -a /dev/stderr | sed 's/; /\n/g' |
		   $IfRun mail -s "$our_name: errors" $sysadmin_email_addresses
	   else rm -f $log
	fi
}

# ----------------------

run_rsync() {
	[[ $1 == -p? ]] && { local pass_opt=$1; shift; } || local pass_opt=
	if [[ $1 == -c ]]
	   then shift
		local is_copy_snapshot=$true
	   else local is_copy_snapshot=$false
	fi
	local dst_snapshot=${!#}
	local src_dirs=${*%$dst_snapshot}

	local date_time=$(basename $dst_snapshot)
	local log=$tmp_dir/$drive_name-${date_time%%.*}.bz2

	if [[ $dst_snapshot == *.partial ]]
	   then local partial_dst=$dst_snapshot
	   else local partial_dst=$dst_snapshot.partial
		# if earlier rsync exists, start with the earlier snapshot
		local suffix
		for   suffix in '' '.links'
		    do	local  useful_dst=$dst_snapshot$suffix
			[[ -d $useful_dst ]] &&
			   $IfRun mv $useful_dst $partial_dst && break
		done
	fi

	case ${pass_opt#-p} in
	   ('') ;;			     # not called by copy_snapshot
	   (0)	;;			     # single-pass
	   (1)	$IfRun mkdir -p $partial_dst; return 1 ;; # for run_prune check
	   (2)	$IfRun rmdir    $partial_dst &> /dev/null ;; # for touch, below
	   (*)	abort "bad pass option: $pass_opt"
	esac

	{		     # ensure $dst_snapshot has current time
	[[ $IfRun ]] ||	     # use 'sleep 9' to wait for rsync to modify mtime
	until [[ -e  $partial_dst || -e $dst_snapshot ]] ; do sleep 9; done
	$IfRun touch $partial_dst	# in case we crash; see next 'touch'
	[[ -f $partial_dst ]] && rm $partial_dst # quick backup??
	} &

	suspend_tracing
	local link_dest_opts=
	set_link_dest_opts $dst_snapshot
	restore_tracing link_dest_opts

	# drive_dir_prefix and rsync_backup_opts come from $config_file
	local relative_opt= excludes=
	[[ ! $is_copy_snapshot ]] &&
	relative_opt=--relative  excludes="--exclude=$drive_dir_prefix*
					   --exclude-from=$exclude_file"
	declare -i start_seconds=$(date '+%s')

	$Trace
	$IfRun rsync $rsync_backup_opts	\
		     $our_rsync_opts	\
		     $relative_opt	\
		     $link_dest_opts	\
		     $excludes		\
			$src_dirs $partial_dst/ |& bzip2 -9 > $log
	local status=${PIPESTATUS[0]}	# https://stackoverflow.com/a/20738063

	$IfRun touch $partial_dst	# 'when we finished', not mdate of src

	_handle_rsync_results $dst_snapshot $status $log

	[[ $pass_opt ]] ||
	$IfRun sync --file-system $dst_snapshot* &> /dev/null

	return $status
}

# -------------------------------------------------------

run_backup_rsync() {

	setup_run_backup_priority && priority=high || priority=low

	if [[ -t 2 ]]
	   then local is_interactive=$true
	   else local is_interactive=$false
	fi

	local date_time
	set_date_time
	local new_snapshot=$drive_dir/$date_time

	if [[ $is_interactive && $drive_name != Z ]] # Z = debug "drive"
	   then echo -n "rsync $dirs_to_backup $new_snapshot/; can CTRL-C ..."
		$IfRun sleep 5
		echo " too late."
	fi

	[[ $UID == 0 || $is_regression_test ]] || $IfRun abort "run with sudo"

	cd_ $drive_dir	# so can safely kill job with: fuser -k -M $drive_dir

	suspend_tracing
	eval "run_rsync $dirs_to_backup $new_snapshot" # might need globbing
	restore_tracing
}

# ----------------------

run_backup() {
	local drive_name=$1 drive_dir

	set_drive_name $drive_name
	set_drive_dir  $drive_name || return 1

	# the following is similar to the second half of copy_snapshot

	# grab lock before prune, so don't suspend prune if the sysadmin
	# suspended the backup and continued the prune
	local lock_file
	set_lock_file run-backup $drive_name
	run_lockpid $lock_file "backing up $drive_dir" || return 1

	_backup_management_of_prune $drive_name pre-rsync

	if _is_time_to_run_backup $drive_dir
	   then	run_backup_rsync
		local status=$?
	   else local status=1
	fi

	_backup_management_of_prune $drive_name post-rsync # last, for testing

	$IfRun lockpid -r $lock_file

	return $status
}

##############################################################################-
##############################################################################-
# Functions and variables used to copy snapshots between backup drives.
##############################################################################-
##############################################################################-

bad_copy() {
	local msg=$*

	[[ $pass_opt || $IfRun ]] || abort "$msg"

	[[ ! $IfRun ]] || echo "copy_snapshot: $msg"

	return 1
}

# ---------------------------------

is_src_snapshot_useful() {
	local src_snapshot=$1

	[[ -d $src_snapshot ]] || bad_copy "no snapshot '$1'" || return 1
	local  src_name=$(basename $src_snapshot)
	[[ $src_name == $snapshot_pattern ||
	   $src_name == $snapshot_pattern.links ]] ||
	   bad_copy "$src_snapshot is not a reliable snapshot" || return 1
	[[ $src_name != *.rm ]] && return 0
	bad_copy "can't copy (partially deleted?) pruned snapshot $src_name"
}

# ---------------------------------

is_dst_snapshot_needed() {
	local dst_snapshot=$1

	set -- ${dst_snapshot%.*}.*	# a version might exist
	[[ $# == 1    ]] ||
	   bad_copy "'$*' exist, (mv then) delete worst one" || return 1
	[[ $1 != *.rm ]] ||
	   bad_copy "destination is waiting to be pruned" || return 1

	local junk_dir=$(dirname $dst_snapshot)/.junk
	$IfRun mkdir -p $junk_dir > /dev/null

	[[ -e $1 ]] || set -- $dst_snapshot
	[[ -e $1 ]] || return 0
	local ext=${1##*.}

	[[ ! -d $1 ]] &&
	   $IfRun mv $1 $junk_dir/ && { warn "junk in $junk_dir"; return 0; }
	! [[ $(basename $1) != *.* || $ext == links || $ext == partial ]] &&
	   $IfRun mv $1 $junk_dir/ && { warn "junk in $junk_dir"; return 0; }

	[[ $1 !=  $dst_snapshot ]] && return 0
	bad_copy "$dst_snapshot already exists"
}

# ---------------------------------

copy_snapshot() {
	[[ $1 == -p? ]] && { local pass_opt=$1; shift; } || local pass_opt=
	[[ $# ==  2  ]] || abort "call as: $FUNCNAME src dst_drive_name"
	local src_snapshot=$1 dst_drive_name=$2

	[[ ! $pass_opt ]] && {		# if -p, caller ran following 2 funcs
	set_drive_name $dst_drive_name
	set_drive_dir $drive_name || abort "$dst_drive_name not mounted"; }
	local  dst_dir=$drive_dir

	is_src_snapshot_useful $src_snapshot || return 1

	dst_snapshot=$dst_dir/$(basename $src_snapshot)
	is_dst_snapshot_needed $dst_snapshot || return 1
	[[ $src_snapshot != *.links || ! -d ${dst_snapshot%.*} ]] ||
	   bad_copy "$src_snapshot is no better than dst $dst_snapshot" ||
	   return 1
	TraceV 2 src_snapshot dst_snapshot

	# the following is similar to the second half of run_backup_rsync

	set_lock_file prune-drive $drive_name	# backup job can suspend us
	run_lockpid $lock_file "copying to $dst_dir" > /dev/null ||
	   exit 1

	setup_merge_priority

	# lower nice value is higher priority
	[[  $cmd_to_set_merge_IO_priority < \
	   $cmd_to_set_higher_IO_priority ]] && priority=high || priority=low

	cd $drive_dir || abort cd # can kill job with: fuser -k -M $drive_dir

	run_rsync $pass_opt -c $src_snapshot/. $dst_snapshot

	$IfRun lockpid -r $lock_file
}

##############################################################################-
##############################################################################-
# Run multiple jobs, each in a separate session (unique PGID, stored in lock).
##############################################################################-
##############################################################################-

# Run a bunch of jobs in parallel, each in its own session (so lock files
# will hold PGID (process-group ID), making 'kill' and 'ps' easy).
# We run backups simultaneously, so they all share the cached source files;
# we run prunes  simultaneously, since a prune's I/O stays on its own drive.
run_jobs_in_parallel() {
	local type=$1; shift

	case $type in
	   ( backup ) function=run_backup  exe=$run_backup_exe  ;;
	   ( prune  ) function=prune_drive exe=$prune_drive_exe ;;
	   (   *    ) abort "'$type' is not supported" ;;
	esac

	if [[ ${1-} == -r ]]		# are we recursing?
	   then shift
		$Trace
		$function $1
		exit $?
	fi

	$Trace
	for dir in ${*:-$(list_drives)}
	    do	if [[ ! $IfRun ]]
		   then trap '' HUP
			# Can't "$function dir &", processes share $tmp* files.
			# Want new process-group so can ps/kill independently.
			setsid \
			$exe -r $dir &
		   else $exe -r $dir	# run in foreground, for testing
			echo
		fi
	done
}

##############################################################################-
##############################################################################-
# 'watch' action.
##############################################################################-
##############################################################################-

format=
for (( i = 1; i <= 26; i++ ))
    do	add_words format '%-6s'
done
readonly stats_format=$format

# ---------------------------------

rsync_hour_avgs=
rsync_hour_maxs=

set__rsync_hour_avgs__rsync_hour_maxs() {

	local hour_avgs= hour_maxs=
	local dir drive_name format=
	for dir in $(list_drives)
	    do	set_drive_name $dir
		local name=$drive_name
		local  dir=$drive_log_dir/$rsync_time_subdir
		eval "set -- $dir/$snapshot_pattern.txt"
		[[ -f $1 ]] || shift
		if [[ $# != 0 ]]
		   then local sum=$(cat $* | tr '\n' '+' | sed 's/+$//')
			eval "declare -i total=$sum"
			hour_avg=$(echo $total $# |
				   awk '{ printf "%.1f", $1/($2*60) }')
			hour_max=$(sort -n $* | tail -n1 |
				   awk '{ printf "%.1f", $1/60 }')
		   else hour_avg= hour_max=
		fi
		add_words hour_avgs $name=$hour_avg
		add_words hour_maxs $name=$hour_max

	done

	printf -v rsync_hour_avgs "$stats_format" $hour_avgs
	printf -v rsync_hour_maxs "$stats_format" $hour_maxs
	rsync_hour_avgs=$(echo "$rsync_hour_avgs" | sed 's/  *$//')
	rsync_hour_maxs=$(echo "$rsync_hour_maxs" | sed 's/  *$//')
}

# -----------------------------------------------------------------------------

_set_age() {
	local snapshot=$1

	set_seconds $snapshot
	declare -i snap_secs=$seconds
	declare -i  now_secs=$(date '+%s')
	age=$(( ($now_secs - $snap_secs)/(24*60*60) ))
}

# ------------------

oldest_age=
newest_age=

_setup_ages() {

	_set_age $1    ; oldest_age=$age
	_set_age ${!#} ; newest_age=$age
}

# ---------------------------------

stats_number=
stats_oldest_age=
stats_newest_age=

setup_snapshot_stats() {
	local suffix=$1 ignored_date_ending_type=${2-null}
	[[ $ignored_date_ending_type == null ]] &&
	   local dates=$true || local dates=$false

	local cwd=$PWD nums= oldies= newies=
	local dir drive_name
	for dir in $(list_drives)
	    do	set_drive_name $dir
		local name=$drive_name
		cd_ $dir
		ending=${type2date_suffix_pattern[$ignored_date_ending_type]}
		ending_RE=${ending//\?/.}
		suspend_tracing
		set -- $snapshot_pattern$suffix
		restore_tracing
		[[ -d $1 ]] || shift
		[[ $# != 0 ]] &&
		set -- $(echo $* | tr ' ' '\n' |
			   sed "s/$ending_RE$//" | uniq)
		restore_tracing

		add_words nums $name=$#

		[[ $dates ]] || continue
		if [[ $# != 0 ]]
		   then _setup_ages $*
			local old=$oldest_age	new=$newest_age
		   else local old=		new=
		fi
		add_words oldies $name=$old
		add_words newies $name=$new
	done
	cd_ $cwd

	suspend_tracing
	local format=
	for (( i = 1; i <= 26; i++ ))
	    do	add_words format '%-6s'
	done
	restore_tracing
	printf -v nums   "$stats_format" $nums		    ; [[ $dates ]] && {
	printf -v oldies "$stats_format" $oldies
	printf -v newies "$stats_format" $newies			    ; }
	stats_number=$(    echo "$nums"   | sed 's/  *$//') ; [[ $dates ]] && {
	stats_oldest_age=$(echo "$oldies" | sed 's/  *$//')
	stats_newest_age=$(echo "$newies" | sed 's/  *$//')		    ; }
}

# -----------------------------------------------------------------------------

trim_prune_rsync() {

	sed -e "s@/bin/bash /@/@"	\
	    -e "s@ bash /@ /@"		\
	    -e "s@ /usr/local/bin/@ @"	\
	    -e "s@$HOME/@~/@g"		\
	    -e "s@prune-drive -r @prune-drive @g" \
	    -e "s@ --.* @ \$opts -R \$dirs @"
}

# ------------------------------------------------------------------

watch() {
	local watch_opt= ps_opt= cron_opt= names=
	[[ ${1-} == -w ]] && { watch_opt=-w; shift; } # internal option
	[[ ${1-} == -f ]] && {    ps_opt=-f; shift; }
	[[ ${1-} == -C ]] && {  cron_opt=-C; shift; }
	[[ ${1-} == -f ]] && {    ps_opt=-f; shift; }
	[[ ${1-} == -N ]] && {     names=$2; shift 2; }
	[[ $is_cron ]] && cron_opt=-C

	local all_opts="$ps_opt $cron_opt"
	[[ $names ]] && add_words all_opts -N $names
	[[ ${SSH_TTY-}  ]] && n=2 || n=0.1
	[[ $action == w ]] ||
	   exec watch ${*:- -n $n} $our_path $our_opts w -w $all_opts

	local drives= names_pat=
	if [[ $names ]]
	   then for name in ${names//,/ }
		    do	set_drive_name  $name
			add_words drives $drive_dir_prefix$drive_name
			[[ $name = ? ]] && names_pat=$names_pat$drive_name
		done
		show_all=$true   cron_opt=-C
	   else show_all=$false
		drives=$(list_drives | tr '\n' ' ')
	fi
	[[ $names_pat ]] && names_pat=[$names_pat]

	[[ $watch_opt ]] || ps_opt=-f cron_opt=-C show_all=$true

	TraceV 1 names drives names_pat ps_opt cron_opt show_all

	# ------------------------------------------------------------------

	set -- $(stty -a | head -n1)
	declare -i rows=${5%;} cols=${7%;}

	# since the contents of $() are run in subshell, have to echo results
	set -- $(
	declare -i max_device_len=0 max_mount_len=0
	df --block-size=G $drives |
	while read device size used avail used mount junk
	    do	declare -i device_len=${#device} mount_len=${#mount}
		is_new_max=$false
		[[ $mount == /* ]] &&	# skip header
		(( $max_mount_len  < $mount_len  )) &&
		    max_mount_len=$mount_len	is_new_max=$true
		(( $max_device_len < $device_len )) &&		  # also header
		    max_device_len=$device_len	is_new_max=$true
		[[ $is_new_max ]] && echo $max_device_len $max_mount_len
	done | tail -n1
	)
	declare -i max_device_len=$1 max_mount_len=$2

	# widest -f -C line is child rsync: 79 cols + wchan + drive mountpoint
	widest_wchan_value=call_rwsem_down_read_failed # linux-3.2
	widest_wchan_value=balance_dirty_pages.isra.17 # linux-3.2
	widest_wchan_value=balance_dirty_pages.isra.24 # linux-4.x
	declare -i max_ps_wchan_width=${#widest_wchan_value}+1
	declare -i ps_wchan_width=10	 # min useful
	declare -i ps_overhead=79

	if (( $cols >= $ps_overhead + $ps_wchan_width + $max_mount_len ))
	   then ps_wchan_width=cols-ps_overhead-max_mount_len  ps_opt=-f
		(( ps_wchan_width > max_ps_wchan_width )) &&
		   ps_wchan_width=max_ps_wchan_width
	fi

	ps_() { ps $ps_opt    "$@" | trim_ps_cols; }
	psc() { ps $ps_opt -C "$@" | trim_ps_cols; }
	if [[ $ps_opt ]]
	   then # don't need uid, always root (if have a TTY, it's a sysadmin)
		trim_ps_cols() { cut -c "10-21,24-37,40-44,46-"; }
		hdr="UID        PID  PPID  C STIME TTY      STAT   TIME CMD"
		#    123456789012345678901234567890123456789012345678901234567
		#             1         2         3         4         5
		prune_sort_opts="-k7r,8 -k9"	rsync_sort_opts="-k11"
	   else trim_ps_cols() { cut -c 1-13,16-20,22-; }
		hdr="  PID TTY      STAT   TIME COMMAND"
		#    123456789012345678901234567890123456789012345678901234567
		#             1         2         3         4         5
		prune_sort_opts="-k5r,6 -k7"	rsync_sort_opts="-k8"
	fi

	# ------------------------------------------------------------------

	customize_and_validate_configuration_variables

	eval \
	"set -- \$(cat $lock_dir/run-backup-${names_pat:-?}.pid 2> /dev/null)"
	[[ $# == 0 ]] && rsync_cmds= ||
	rsync_cmds=$(ps_ -H ww  $(echo " $*" | sed 's/ / -/g') |
			grep "[0-9]   rsync" | sed 's/   rsync/ rsync/')
	declare -i num_rsyncs=$(echo "$rsync_cmds" | wc -l)
	declare -i num_drives=$(list_drives | wc -l)

	[[ $rsync_cmds || -s /etc/sudoers.d/$_our_name ]] || {
		header "to not fill the log with frequent 'sudo ps'"
		option_1="install etc/sudoers.d/$our_name"
		option_2="put its contents into /etc/sudoers"
		echo -e "\n$option_1, or $option_2\n"
	}

	eval \
	"set -- \$(cat $lock_dir/prune-drive-${names_pat:-?}.pid 2>/dev/null)"
	prune_cmds=$(ps_ w h $(echo " $*" | sed 's/ / -/g')	  2>/dev/null |
			trim_prune_rsync)
	#
	cron_job_regexp=' -C run-backups? *$' # put into configure.sh ??
	set -- $(ps -u root w | egrep "$cron_job_regexp" | awk '{print $1}')

	[[ ($cron_opt || ! $rsync_cmds) && $# != 0 ]] && {
	set_PGID $*
	cron_PGIDs=$PGID
	set -- $(process_group_PIDs $cron_PGIDs)
	[[ $ps_opt ]] && wchan=,wchan:$ps_wchan_width || wchan=
	[[ $wchan ]] && sudo ps > /dev/null && sudo=sudo || sudo=
	#  option f for "forest"
	cron_cmds=$($sudo ps www f -o pid,stat$wchan,bsdtime,command $*)
	} || cron_cmds=

	# -C + df: 25 lines of overhead; 2 lines/drive; 9 lines per rsync+rm
	#   (ignoring the ~500 characters for full-detail for: rsync /)
	# includes basic pruning, but not parent of 'rm' process (since in -C)
	declare -i PB_num=$(echo "$prune_cmds" | fgrep -c prune-drive)
	declare -i min_C_rows=$(( 27 + num_drives + 5*num_rsyncs + 2*PB_num ))
	declare -i min_C_df_rows=$(( min_C_rows + 2 + num_drives ))
	# echo $rows $min_C_df_rows

	# ------------------------------------------------------------------

	psc rm w | fgrep ' pts/' | sort $prune_sort_opts > $tmp
	# could parameterize this restriction with 'stty' data
	if [[ -s $tmp && ( $show_all || ! ( $cron_opt && $rsync_cmds ) ) ]]
	   then header -E "ad-hoc pruning by sysadmin (i.e. TTY != '?')"
		echo
		echo "$hdr" | trim_ps_cols
		sed 's@\([0-9] rm [^0-9]*[0-9][^ ]* \).*@\1...@' $tmp
		echo
	fi
	rm $tmp
	# ------------------------------------------------------------------
	[[ $cron_opt && $rsync_cmds && ! $show_all && $rows -lt $min_C_rows ]] || {
	header -E "cron's run-prune"
	echo
	> $tmp
	[[ $prune_cmds ]] && {
	echo "$cron_cmds" | sed -n 's/.*prune-drive/prune-drive/p' > $tmp_2
	[[ $cron_opt && $rsync_cmds && ! $show_all ]] && # && $rows < ???
	   prune_cmds=$(echo "$prune_cmds" | fgrep -v -f $tmp_2)
	echo "$prune_cmds" | fgrep -v -w -e xargs -e tr
	} | sort $prune_sort_opts > $tmp
	if [[ -s $tmp ]]
	   then echo "$hdr" | trim_ps_cols
		cat $tmp
	   else echo -e "No pruning is being done."
	fi
	rm $tmp

	echo
	set__rsync_hour_avgs__rsync_hour_maxs
	echo "Average hours to create rsync snapshot:  $rsync_hour_avgs"
	echo "Maximum hours to create rsync snapshot:  $rsync_hour_maxs"
	echo
	setup_snapshot_stats .rm
	echo " Number pruned snapshots awaiting 'rm':  $stats_number"
	echo "  Age of newest pending prune, in days:  $stats_newest_age"
	setup_snapshot_stats .links
	echo "  Number of 'Too many links' snapshots:  $stats_number"
	echo "     Days since 'Too many links' error:  $stats_newest_age"

	[[ $rsync_cmds && ! $show_all ]] || { # && $rows < ???
	echo
	setup_snapshot_stats ''
	echo "     Total number successful snapshots:  $stats_number"
	echo "  Age of oldest good snapshot, in days:  $stats_oldest_age"
	echo "  Age of newest good snapshot, in days:  $stats_newest_age"
	setup_snapshot_stats '' hour
	echo "  Total number  days  w/good snapshots:  $stats_number"
	setup_snapshot_stats '' day
	echo "  Total number months w/good snapshots:  $stats_number"
	setup_snapshot_stats '' month
	echo "  Total number years  w/good snapshots:  $stats_number"
	}
	}

	# ------------------------------------------------------------------

	[[ $cron_opt && $rsync_cmds && $rows -lt $min_C_df_rows && ! $show_all ]] || {
	echo
	df_fields=source,fstype,size,avail,used,pcent,iused,ipcent,target
	df --block-size=G --output=$df_fields  $drives
	}

	[[ ( $cron_opt || $rsync_cmds ) && ! $show_all ]] || {
	devices=
	for dir in $drives
	    do	set_FS_device___from_path $dir &&
		add_words devices $FS_device
	done
	# fields that don't work: rm,model,opt-io,rota
	lsblk_fields=name,fstype,type,size,state,sched,mountpoint
	type lsblk &>/dev/null && echo &&
	lsblk --output=$lsblk_fields $devices
	}

	# ------------------------------------------------------------------

	# {copy,update,merge}-drive use prune lock (but not yet setid)
	eval \
	"set -- \$(cat $lock_dir/prune-drive-${names_pat:-?}.pid 2>/dev/null)"
	[[ $# == 0 ]] && cp_rsync_cmds= ||
	cp_rsync_cmds=$(ps_ -H ww  $(echo " $*" | sed 's/ / -/g') |
			grep "[0-9]   rsync" | sed 's/   rsync/ rsync/')
	[[ $cp_rsync_cmds ]] ||
	cp_rsync_cmds=$(psc rsync -H ww | fgrep ' pts/' |
			grep "[0-9]   rsync" | sed 's/   rsync/ rsync/')
	[[ $cp_rsync_cmds ]] && {
	header "copy-snapshot, or ad-hoc rsync by sysadmin (i.e. TTY != '?')"
	echo
	echo "$hdr" | trim_ps_cols
	echo "$cp_rsync_cmds" | trim_prune_rsync | sort $rsync_sort_opts
	}

	# ------------------------------------------------------------------

	# for some reason, appending newlines does nothing?!
	rsync_abbrev_msg="
	  default opts=\"$rsync_backup_opts\" (\$rsync_backup_opts)
	  default dirs=\"$dirs_to_backup\" (\$dirs_to_backup)
	"
	rsync_abbrev_msg=$(echo "$rsync_abbrev_msg" | sed 's/^\t//')

	[[ $cron_opt && $rows -lt $min_C_rows && ! $show_all ]] || {
	    header "cron's primary run-backup processes (abbreviated)"
	    [[ $rsync_cmds ]] && {
	    echo "$rsync_abbrev_msg"; echo
	    echo "$hdr" | trim_ps_cols
	    echo "$rsync_cmds" | trim_prune_rsync | sort $rsync_sort_opts
	    } || echo -e "\nNo backups are running."
	}

	# ------------------------------------------------------------------

	# show process tree of master cron job(s)
	[[ $cron_cmds ]] && {
	stime=$(set -- $(ps h -o stime $cron_PGIDs | sort -u); echo $*)
	regex=${cron_job_regexp%%s*}
	header "$stime: '$regex' cron job(s), PGID='$cron_PGIDs'"; echo
	(( $rows < $min_C_rows )) && echo "${rsync_abbrev_msg#?}" && echo
	echo "$cron_cmds" | trim_prune_rsync
	}

	[[ $rsync_cmds ]] && {
	header "cron's primary run-backup processes (full details)"
	echo
	echo "$hdr" | trim_ps_cols
	echo "$rsync_cmds" | sed "s@$HOME/@~/@g"
	}
}

##############################################################################-
##############################################################################-
# Functions for creating/altering filesystems.
##############################################################################-
##############################################################################-

# add-extN-journal drive_name [FS_device [VG_name]]: fast external journal
add_extN_journal() {
	[[ ${1-} == -M ]] && { local  do_mount=  ; shift; } || local do_mount=t
	[[ ${1-} == -f ]] && { local force_opt=$1; shift; } || local force_opt=
	[[ $# == [1-4] ]] ||
	   abort "{-l FS_label | drive_name} [device [VG-name]]"
	if [[ $1 == -l ]]
	   then shift;  FS_label=$1
	   else name=$1 FS_label=
	fi
	FS_device=${2-} VG_name=${3-}

	[[ $UID == 0 ]] || $IfRun abort "run with sudo"

	[[ ! $FS_label ]] && {
	is_OK_if_drive_dir_unmounted=$true
	set_drive_name $1
	set_drive_dir $drive_name
	set_FS_label___from_mount_dir $drive_dir ; }
							[[ $FS_device ]] ||
	set_FS_device___from_FS_label $FS_label
	[[ ${mount_dir-} ]] || set_mount_dir___from_FS_device $FS_device
	TraceV 1 force_opt FS_label FS_device VG_name mount_dir

	sudo tune2fs -l $FS_device | grep -q '^Journal ' &&	  {
	warn "removing internal journal can take many minutes"
	$IfRun tune2fs $force_opt -O ^has_journal $FS_device	; }

	set_FS_external_log $force_opt $FS_label $VG_name ||
	warn "invalid set_FS_external_log, or $config_file says log unwanted"||
	   { $IfRun tune2fs -j $FS_device; return $?; }
	label=$(basename $FS_external_log)

	$Trace

	$IfRun mke2fs -v -b 4096 -O journal_dev -L $label $FS_external_log ||
	   abort "mke2fs -O journal_dev -> $?"

	[[ ${name-} ]] && {
	suspend_tracing
	$our_path $our_opts umount $drive_dir |&
	   grep -v -e ': no filesystem mounted on ' -e '^ *$'
	is_drive_mounted $drive_dir && $IfRun abort "umount $drive_dir"
	restore_tracing
	} || $IfRun umount $FS_device &> /dev/null
	mount  |  fgrep -w $FS_device && $IfRun abort "must: umount $FS_device"

	$IfRun tune2fs -J device=LABEL=$label $FS_device ||
	   abort "tune2fs -J attempt to attach journal -> $?"
	$IfRun tune2fs -l $FS_device | grep -i "journal [id]"
	local status=${PIPESTATUS[0]}

	[[ $do_mount ]] || return $status

	mount_options=$common_mount_options,$ext4_mount_options
	$IfRun \
	mount -v -t ext4 -o ${mount_options%,} $FS_device $mount_dir ||
	   abort "mount exited with $?"
}

# -----------------------------------------------------------------------------

total_dir_MB=
avg_dir_KB=

set__total_dir_MB__avg_dir_KB() {
	local file=${1%.bz2}.bz2

	isize=$(echo $file | sed -r 's/.*-inode=([0-9]+)-.*/\1/')
	set -- $( bzcat $file |
		  awk --assign isize=$isize --field-separator K \
			'{ space += ($1*1024) + isize; count += 1 }
			 END { printf "%.1f %.2f\n",
					space/(1024*1024),
					space/(1024*count)}' )
	total_dir_MB=$1 avg_dir_KB=$2
}

# --------------------------------------------

# dir-sizes [-f [file] | name]: stats for 'mkfs'; -f -> list/use old data
dir_sizes() {
	set__drive_log_dir__file_for_logging__admin_group__is_regression_test
	readonly sizes_dir=$drive_log_dir/dir-sizes
	mkdir -p -m g+w,o-w $sizes_dir || abort "need to use sudo"
	cd_ $sizes_dir

	suffix=ls-s

	if [[ $# == 0 ]]
	   then echo -e "\nThe actual disk-space consumed by a directory is"
		echo -e "the size of: its directory block(s) plus its inode:\n"
		set -- *.$suffix.bz2
		[[ -f $1 ]] ||
		   abort "no saved data files, you need to run: $our_name name"
		for file
		    do	set__total_dir_MB__avg_dir_KB $file || continue
			space="all dirs use $total_dir_MB MB/snapshot"
			  avg="$avg_dir_KB KB/dir"
			printf "%46s: %s\n" "$space ($avg)" ${file%%.*}
		done | sort -k4n	# sort by total size
		echo
		exit
	fi
	[[ $1 =~ ^[0-9]+\.?$ ]] && set -- -f $*
	if [[ $1 == -f ]]
	   then file=${2-}
		set -- *.$suffix.bz2	# the saved files
		if [[ $file ]]
		   then if [[  $file =~ ^[0-9]+\.?$ ]]
			   then file=${file%.}
				eval  "file=\${$file-}"
				[[ -s $file ]] ||
				   abort "invalid number:\n$($our_name -f)"
			elif [[  ! -f $file && ! -f $file.bz2 ]]
			   then err_msg="file '$file' doesn't exist"
				if [[ $file != /* ]]
				   then err_msg="$err_msg in $PWD/"
					abort "$err_msg ; use absolute path??"
				   else abort "$err_msg"
				fi
			elif [[ ! -f $file ]]
			   then file=$file.bz2
			fi
		   else echo
			for (( i = 1; i <= $#; i++ ))
			    do	eval "file=\${$i}"
				echo "$i. ${file%.bz2}"
			done
			echo -e "\nUse a filename or above number with -f\n"
			exit 1
		fi
	   else file=  name=${1-}
		[[ $# == 1 && $name && $name != -* ]] ||
		   abort_with_action_Usage dir-size
		set_drive_name $1
	fi

	[[ $file ]] || {

	drive_dir=$drive_dir_prefix$drive_name
	if [[ -d $drive_dir/latest ]]
	   then excludes=   dirs_to_backup=$drive_dir/latest/.  where=
	   else excludes="--exclude=$drive_dir_prefix*
			  --exclude-from=$exclude_file"
		   problem="missing '$drive_dir/latest' snapshot symlink"
		solution_1="you can hit CTRL-C, and either: create symlink"
		solution_2="use 'dirs_to_backup' variable to check root drive"
		warn "$problem: $solution_1, or $solution_2"
		where=-root
	fi

	dir=${dirs_to_backup%% *}
	set_FS_type___from_path $dir
	set__inode_size__data_block_size__dir_block_size___from_path $dir
	type=$FS_type dirblock=$dir_block_size inode=$inode_size
	file=$type-dirblock=$dirblock-inode=$inode-$drive_name$where.$suffix
	TraceV 1 dirs_to_backup file

	[[ ! $IfRun ]] ||
	   abort "use '-T 1' or '-t' instead of '-d' (-d only works with -f)"
	[[ $UID == 0 ]] || abort "need to use sudo"

	rsync --dry-run --verbose --recursive --relative \
		  $excludes		      \
		--include='*/' --exclude='*'  \
		      $dirs_to_backup  /tmp/  |
	   grep '^/' |
	   # head -n 100 |		# uncomment to debug
	   tr '\n' '\0' | xargs -0 ls --block-size=K -sd |
	   sed -r 's/^ *([0-9]+K) +/\1|/' | # pipe-separate fields
	   sort -t '|' -k1n,1 -k2	  | # for histogram & compression
	   awk  -F '|' '{ printf "%6s\t%s\n", $1, $2 }' | # more readable
	   bzip2 -9 > $file.partial.bz2 && mv $file.partial.bz2 $file.bz2
	   [[ $? == 0 && ${PIPESTATUS[0]} == 0 ]] ||
	      abort "something bad happened"
	}

	file=${file%.bz2}
	header $file

	set -- $(bzcat $file.bz2 | wc -l)
	declare -i dir_count=$1
	declare -i median_line=$dir_count/2
	set -- $(bzcat $file.bz2 | sed -n ${median_line}p)
	printf "\n%7s directories.\n" $dir_count
	bzcat $file.bz2 |
	awk '    { KB += $1; count += 1 }
	     END { printf "Average directory size is %.1f KB\n",
				KB/count }'

	echo -e " Median directory size is ${1%K} KB ...\n"
	$Trace
	(( $dir_count > 100 )) && {
	declare -i decile_count=$(( ($dir_count + 5) / 10 )) i
	declare -i decile_median_line=decile_count/2
	for i in {0..9}
	    do	set -- $(bzcat $file.bz2 | sed -n ${decile_median_line}p)
		echo "Decile $i has median directory size of ${1}B"
		decile_median_line+=decile_count
	done
	echo
	}

	echo "--> histogram of directory sizes <--"
	echo "  count size"
	echo "  ----- ----"
	bzcat $file.bz2 | cut -f1 | uniq -c | sort -nr | head
	echo -e "    ...\n"

	set__total_dir_MB__avg_dir_KB $file.bz2
	echo "BUT...  The actual disk-space consumed by a directory is"
	echo "the size of its directory block(s) plus the size of its inode:"
	space="$total_dir_MB MB/snapshot"
	  avg="$avg_dir_KB KB/dir"
	echo -e "\n  all directories consume $space ($avg)\n\n"
}

# -----------------------------------------------------------------------------

# Here's how to setup a brand new drive to be an encrypted drive

# If brand new drive, find its device name with: ls -lt /dev/sd?
# Save the device name and drive name: device=/dev/sdX  drive=Y
# Verify it's a new drive (which has partition table): fdisk -l $device
# See if someone is using it: fuser -v $device
# cryptsetup luksFormat $device /etc/snapcrypt/keys/keyfile.bin
#   (be SURE you type "YES" not "yes")
# Make sure encryption succeeded: fdisk -l $device # want no partitions
# Then run: snapcrypt open $device $drive (mount will fail).
# Then create new rule in /etc/snapcrypt/drives.rules .
# If have existing backup drives that are no bigger, use copy-drive .

# mkfs device [name]: prepare blank first- or smallest-drive (see comments)
mkfs_backup_drive() {
	set_date_time
	line_1="if you're using a partition or LV that already has backups,"
	line_2="you can keep them, if you rename them as /Year-Mo-Da,Hr/ , "
	line_3="e.g. 'now' looks like /$date_time/ ; don't run 'mkfs',"
	line_4="just re-label the partition and change its record in /etc/fstab"
	line_5="(which is not needed if the partition is auto-mounted)."
	warn "$line_1\n   $line_2\n   $line_3\n   $line_4\n   $line_5"

	[[ ${1-} == -f ]] && shift || {
	   echo "if this is your first or smallest disk, use the -f option;"
	   echo "otherwise, use action 'copy-drive' instead."
	   abort_with_action_Usage mkfs
	} >&2
	mkfs_opts=$(echo " $*" | sed -r 's@^(.*) /dev/.*@\1@')
	set  --   $(echo " $*" | sed -r 's@.* /dev/@/dev/@')
	[[ $# == [12] ]] || abort_with_action_Usage mkfs
	device=$1 name=${2-}
	TraceV 3 mkfs_opts device name
	[[ $device = /* ]] || device=/dev/$device
	[[ -b $device ]] || $IfRun abort "$device not a block device"

	if [[ $name ]]
	   then set_drive_name $name
	   else set_drive_name $device
	fi
	name=$drive_name
	drive_dir=$drive_dir_prefix$drive_name
	_mkfs_cmd_opts=$mkfs_cmd_opts
	add_words _mkfs_cmd_opts $mkfs_opts

	set_FS_label___from_mount_dir $drive_dir

	# Since most files are shared between many snapshots, most of our
	# inodes are directories; so directory size determines space usage, so
	# we should choose a block size that will result in the smallest space
	# usage by directories (unless we only backup files that change often,
	# and they're large enough that ext* needs to use indirect blocks).
	# On my Ubuntu laptop, 1 KB blocks result in half the disk space used
	# by 2 KB blocks, so the default block size is 1KB; on HRDAG's Ubuntu
	# server using XFS, 1 KB blocks are also optimal.  To determine the
	# actual average directory size, you should create a default backup
	# drive, run 'run-backup <drive-name>, then run 'snapback dir-sizes
	# <drive-name>' where the drive-name is used to set 'dirs_to_backup'
	# and excludes.  ALSO, by making the block size smaller, you'll be
	# able to have more inodes, see: https://askubuntu.com/a/1104944 .
	# Having small blocks might reduce performance on a rotational hard
	# disk (unless you're using extents and rsync's --preallocate), but
	# probably won't affect performance on an SSD or flash memory stick
	# unless you have lots of files with indirect blocks.

	# this block of code is only relevant to ext*
	[[ $_mkfs_cmd_opts != mkfs.[^e]* ]] && {
	block_size=1024			# optimal, see above long comment
	set -- $_mkfs_cmd_opts
	while [[ $# != 0 ]]
	   do	[[ $1 == -b       ]] && block_size=${2-}
		[[ $1 == -b[0-9]* ]] && block_size=${1#-b}
		shift
	done
	valid_block_sizes="1024 2048 4096"
	is_arg1_in_arg2 $block_size $valid_block_sizes ||
	   abort "ext* block size must be one of: $valid_block_sizes"
	blocks_per_inode=1
	let  bytes_per_inode=$blocks_per_inode*$block_size
	TraceV 3 block_size bytes_per_inode
	}

	# There's no need to store small-files or file's extended-attributes
	# in inodes: The extra blocks used for small-files or out-of-inode
	# extended-attributes will be shared between snapshots, since file
	# inodes are shared between snapshots.  So, we want small inodes.
	# EXCEPT: If most of the backed-up _directories_ have
	# extended-attribute-blocks, then select an inode size that will hold
	# the average set of extended-attributes.  If you want to backup
	# nanosecond timestamps or file creation time on ext*, then use >= 256;
	# otherwise, use 128.

	# https://lwn.net/Articles/645722/ : 4/15: fixed ext4 extent corruption
	# https://en.wikipedia.org/wiki/Linux_kernel#Releases_4.x.y
	if [[ $FS_type == ext4 && $(uname -r) > 4.2.7 ]]
	   then ext4_extent_opt="-O extent"
	   else ext4_extent_opt=
	fi

	set -- $_mkfs_cmd_opts
	cmd=$1; shift; opts=$*  log_opt=
	  if [[ $cmd == mkfs.xfs ]]
	   then FS_type=xfs
		[[ $(which mkfs.xfs) ]] || $IfRun abort "install xfsprogs"
		# The above comment predicts size=256; but CRCs need size=512,
		# and 90% of HRDAG's server's dirs fit in a size=512 inode.
		# For servers with bigger dirs, experiment with different
		# mkfs opts (on your fastest drive) and the dir-sizes action.
		[[ $opts == *"-i size="* ]] || add_words opts -i size=512
		[[ $opts == *"-s size="* ]] || add_words opts -s size=2048
		[[ $opts == *"-b size="* ]] || add_words opts -b size=2048
		[[ $opts == *"-n size="* ]] || add_words opts -n size=2048
		[[ $opts == *maxpct=*    ]] || add_words opts -i maxpct=0
		mount_opts="$XFS_mount_options"
		type set_FS_external_log &> /dev/null && # optional
		     set_FS_external_log $FS_label &&
		logdev="logdev=$FS_external_log" &&
		log_opt="-l $logdev"  mount_opts=$mount_opts,$logdev
	elif [[ $cmd == mkfs.ext? ]]
	   then FS_type=${cmd#*.}
	elif [[ $cmd == mke2fs ]]
	   then FS_type=$(echo $opts | sed -r 's/.*\W-t\W*(\w+)\b.*/\1/')
		[[ $FS_type ]] || FS_type=ext4
	elif [[ $cmd != mk* ]]
	   then abort "the value of 'mkfs_cmd_opts' should start with 'mk'"
	   else abort "don't support '$cmd $opts', email $coder"
	fi
	#
	if ! [[ $FS_type == ext? && $IfRun && $UID == 0 ]]
	   then mkfs_debug_opt=
	   else mkfs_debug_opt=-n
		warn "running mkfs.$FS_type in debug mode ..."
	fi
	if [[ $FS_type == ext? ]]
	   then add_words opts -v
		[[ $opts != *-T* ]] && {
		[[ $opts != *-b* ]]	&& add_words opts -b $block_size
		[[ $opts != *-i* ]]	&& add_words opts -i $bytes_per_inode
		[[ $opts != *-I* ]]	&& add_words opts -I 128	; }
		[[ $opts != *-m* ]]	&& add_words opts -m .1
		[[ $opts != *extent* ]] && add_words opts $ext4_extent_opt
		[[ $FS_type == ext4  ]] &&
		mount_opts="$ext4_mount_options"
		type set_FS_external_log &> /dev/null	&& # optional
		     set_FS_external_log $FS_label	&&
		log_label=$(basename $FS_external_log)	&&
		$IfRun mke2fs -v -b $block_size -O journal_dev \
			 -L $log_label $FS_external_log &&
		add_words opts -J device=LABEL=$log_label
	fi

	df -m | grep " $drive_dir$" &&
	  $IfRun abort "there's already a filesystem mounted on $drive_dir"
	[[ $FS_type == xfs && $opts == *' -N '* ]] || {
	[[ -d $drive_dir ]] &&
	  $IfRun abort "directory $drive_dir/ exists: is name '$name' in use?"
	df -m | grep "^$device[ 	]" &&
	  $IfRun abort "that device is mounted; to *DESTROY* its contents,
			first run: umount $device"
	}

	[[ $UID == 0 ]] || $IfRun abort "run with sudo"

	[[ $mount_opts ]] && mount_opts=,$mount_opts
	mount_opts=$common_mount_options$mount_opts
	rec="\n\n\tLABEL=$FS_label\t$drive_dir\t$FS_type\t$mount_opts 0 2"
	warn "sample record for /etc/fstab (optional with 'snapcrypt'):$rec"

	[[ $mkfs_debug_opt ]] && IfRun= opts=$(echo $opts | sed 's/ -J .*//')
	cmd="$IfRun $cmd $opts $log_opt $mkfs_debug_opt -L $FS_label $device"
	header $cmd
	$cmd || abort "$cmd exited with $?"
	[[ $mkfs_debug_opt ]] && IfRun=echo
	$IfRun mkdir -p $drive_dir
	cmd="$IfRun mount -v -t $FS_type -o $mount_opts $device $drive_dir"
	$cmd || abort "$cmd exited with $?"
}

# -----------------------------------------------------------------------------

# these 3 variables are global variables initialized elsewhere
set__drive_name__FS_device__drive_dir__FS_label() {
	device=$1 name=$2

	[[ $device$name ]] || abort "need 1 non-null argument"

	[[ $name ]] && set_drive_name $name && name=$drive_name
	[[ !  $device ]] &&
	   set_FS_label___from_mount_dir $drive_dir_prefix$name &&
	   set_FS_device___from_FS_label $FS_label && device=$FS_device
	[[ -b $device ]] || abort "$device is not a block device"

	if [[ ! $name ]]
	   then set_FS_label___from_FS_device $device
		name=$FS_label
	fi

	FS_device=$device
	set_drive_name $name
	drive_dir=$drive_dir_prefix$drive_name
	set_FS_label___from_mount_dir $drive_dir

	TraceV 1 device name drive_name FS_device drive_dir FS_label
}

# ---------------------------------

# copy-drive {src_name | ''} dst_name dst_dev: copy (default oldest) to dst
copy_backup_drive() {
	action_opts=
	while [[ ${1-} == -* ]] ; do add_words action_opts $1; shift; done
	[[ $# != 0 ]] ||
	abort "[-f] [-M] [-F] {src_name | ''} {dst_name dst_dev | '' dst_dev | dst_name}"
	src_name=$1 dst_name=$2 dst_device=${3-}

	[[ -t 1 ]] || abort "don't use 'nohup', we'll run 'nohup'"

	warn "the new device MUST be as-large as src_name's device"

	set__drive_name__FS_device__drive_dir__FS_label \
	    "$dst_device" $dst_name
	local dst_name=$drive_name
	local dst_device=$FS_device
	local dst_drive_dir=$drive_dir
	local dst_FS_label=$FS_label

	[[ ! $src_name ]] &&
	set_oldest_snapshot && 
	set_drive_name $(dirname $oldest_snapshot) &&
	local src_name=$drive_name

	set__drive_name__FS_device__drive_dir__FS_label "" $src_name
	local src_name=$drive_name
	local src_device=$FS_device
	local src_drive_dir=$drive_dir
	local src_FS_label=$FS_label

	# show the user a sample fstab record
	$our_path -d mkfs -f $dst_device $dst_name |&
	   # search for the last two fields in the fstab record
	   egrep -B 3 -A 1 "[[:space:]][0-9]+[[:space:]]+[0-9]+[[:space:]]*$"

	set --	$our_path $our_opts finish-$action $action_opts \
		$src_device $src_drive_dir \
		$dst_device $dst_drive_dir
	cmd=$*

	[[   $IfRun ]] && header "$_our_name ${cmd#* }"
	[[ ! $IfRun ]] || exec $cmd || abort "$IfRun $cmd -> $?"

	output_file=$dst_FS_label.out
	echo -e "
	nohup'ing slow 'dd' to copy partition '$src_name' to '$dst_name',
	followed by slow fsck: takes about a day per TB of disk.  We'll
	'exec tail -f $output_file'; you can hit CTRL-C when you get bored.
	"
	nohup $cmd > $output_file &
	sleep 0.1; set -x; exec tail -f $output_file
}

# ------------------------------------------------------------------

# finish-copy-drive: copy, label & UUID, replace journal, fsck, mount, resize
finish_copy_backup_drive() {
	action_opts=
	while [[ ${1-} == -* ]] ; do add_words action_opts $1; shift; done
	[[ $# == 4 ]] || 
	   abort "to see args, run: $_our_name -d cpdrv {src_name | ''} dev [dev_name]"
	local src_device=$1 src_drive_dir=$2
	local dst_device=$3 dst_drive_dir=$4

	is_arg1_in_arg2 -f $action_opts ||
	for drive_dir in $src_drive_dir $dst_drive_dir; do
	if is_drive_mounted $drive_dir
	   then set -- $(list_drives | 
			 fgrep -v -w -e $src_drive_dir -e $dst_drive_dir)
		[[ $# == 0 ]] &&
		msg="
	There are no other backup partitions mounted besides the ones used to
        copy $src_drive_dir to $dst_drive_dir ; if you let me unmount these
	partition(s), no new backups will be made for many hours (or days).

	You might instead run '$_our_name mkfs' on the new drive, leave the old
	drive mounted, and run:

		cd $src_drive_dir
		nohup rsync -aSHX * $dst_drive_dir/ &

	To instead unmount both drives and do a fast 'dd'," ||	msg="
	$src_drive_dir is mounted;"
		abort "\n$msg re-run copy-drive with -f to Force unmount."
	fi; done

	set_FS_type___from_path $src_device &&
	[[ $FS_type == xfs ]] &&
	   abort "build and mount $dst_drive_dir with '$_our_name mkfs', then put 'xfsdump -J - $src_drive_dir | xfsrestore -J - $dst_drive_dir' in a script and run it with 'nohup'"

	trap '' HUP

	$Trace

	[[ $UID == 0 ]] || $IfRun abort "run with sudo"

	for drive_dir in $src_drive_dir $dst_drive_dir
	    do	$our_path $our_opts umount $drive_dir |&
		   grep -v -e ': no filesystem mounted on ' -e '^ *$'
		is_drive_mounted $drive_dir &&
		    $IfRun abort "umount $drive_dir"
	done

	$IfRun set -x

	$IfRun dd if=$src_device of=$dst_device bs=1M || abort "dd -> $?"

	$IfRun tune2fs -U $(uuidgen) $dst_device

	label_drive $dst_device $dst_drive_dir

	local dst_name=${dst_drive_dir#$drive_dir_prefix}
	suspend_tracing
	customize_and_validate_configuration_variables $dst_name
	restore_tracing dst_name

	if sudo tune2fs -l $src_device | grep -q "^Journal device" || # extrnl?
	   [[ $do_want_external_log ]]
	    then add_extN_journal -M $dst_name $dst_device || abort aej
	fi

	local mount_options=$common_mount_options,$ext4_mount_options
	mount_options=${mount_options%,}

	is_arg1_in_arg2 -M $action_opts || {
	cmd="$IfRun mount -t $FS_type -o $mount_options $src_device $src_drive_dir"
	$cmd || abort "$cmd exited with $?"
	}

	is_arg1_in_arg2 -F $action_opts || {
	cmd="$IfRun e2fsck -f -p -t -t -E discard $dst_device"
	$cmd || abort "$cmd exited with $?; better check $src_device ?!"
	}

	$IfRun mkdir -p $dst_drive_dir
	$IfRun \
	mount -t $FS_type -o $mount_options $dst_device $dst_drive_dir ||
	   abort "mount exited with $?; make mount happen, then run resize2fs"
	$IfRun resize2fs $dst_device	# do this _after_ mount, for speed
}

# -------------------------------------------------------

# copy-backup-drive-dump name: dump oldest mounted backup to $1: SLOW
copy_backup_drive_with_dump() {
	abort "this is incredibly slow, use copy-drive instead"
	abort "this code is out of date, needs to be rewritten"

	# cp is probably faster than dump, if use setup_RAM_FS_journal:
	# cmd="cp -al $snapshot_pattern ${drive_dir_prefix}new/"

	[[ $# == 1 && $1 == [a-zA-Z] ]] || abort "specify backup drive letter"
	letter=${1^}
	new_device=/dev/mapper$drive_dir_prefix$letter
	[[ -b $new_device ]] || abort "can't find device for $letter"
	[[ $UID == 0 ]] || $IfRun abort "run with sudo"

	have_cmd dump && have_cmd restore ||
	    abort "need to run: sudo apt-get install dump"

	set_oldest_snapshot
	drive_dir=$(dirname $oldest_snapshot)
	device=$(df --output=source $drive_dir | fgrep /dev/)
	cd_ /tmp/root
	$our_path $our_opts umount  $drive_dir

	$IfRun umount $new_device &> /dev/null
	$IfRun mkdir -p		${drive_dir_prefix}new
	$IfRun mount  $new_device ${drive_dir_prefix}new ||
	   abort "mount $new_device -> $?"

	cmd="cp -al $snapshot_pattern ${drive_dir_prefix}new/" # only if setup_RAM_FS_journal
	# see Part 3 of: https://stackoverflow.com/questions/37488629/how-to-use-dump-and-restore-to-clone-a-linux-os-drive
	$IfRun set -x
	$IfRun cd_ ${drive_dir_prefix}new
	$IfRun dump -a0f - $device | $IfRun restore -rf - ||
	   warn "dump | restore"
	exit_status=$?
	$IfRun set +x
	$IfRun cd_ /tmp
	[[ $exit_status == 0 ]] && {
	$IfRun umount ${drive_dir_prefix}new
	label_drive $new_device $mount_dir
	$IfRun mount  $new_device $mount_dir || warn "mount $new_device"
	}
	$IfRun mount $device $drive_dir ||
	   abort "mount $device $drive_dir -> $?"
}

#############################################################################
#############################################################################
# Process the requested action with the above functions & global variables. #
#############################################################################
#############################################################################

[[ $# != 0 ]] || abort "specify an action to perform\n$Usage"

action=$1; shift
_our_name="$our_name"
 our_name="$our_name $action"

process_action() {

stack_frame_to_show=0	     # show our line-number in action 'case- statement

case $action in
   # list-drives: list all the mounted backup drives or partitions
   ( l*s*dr*v* | ld | ls )
	list_drives
	;;
   # run-backups  [dir(s)]: dir(s) defaults to every mounted backup drive
   ( r*b*k*p* | rb* )
	run_jobs_in_parallel backup "$@"
	[[ $is_cron ]] && wait		# so see master cron job in ps
	;;
   # prune-drives [dir(s)]: dir(s) defaults to every "" "" ""; see configure.sh
   ( pr*n*dr*v* | pd* )
	run_jobs_in_parallel prune "$@"
	[[ $is_cron ]] && wait		# so see master cron job in ps
	;;
   # copy-snapshots src(s) name: copy src(s) to 'name' mounted backup drive
   ( c*p*s*s* | cs* | cps )
	warn "fix: require -f if src/dst excludes or dirs_to_backup differ"
	dst_name=${!#}
	src_snapshots=${*%$dst_name}

	[[ $UID == 0 || $is_regression_test ]] || $IfRun abort "run with sudo"

	for snapshot in $src_snapshots
	    do	copy_snapshot $snapshot $dst_name
	done
	;;
  # update-drive name: 'name' mounted drive gets snapshots from other drives
   (upd*b* | ud )
	set_drive_name $1
	set_drive_dir $drive_name

	[[ $UID == 0 ]] || $IfRun abort "run with sudo"

	$Trace

	set -f
	set -- $(echo root$drive_dir_prefix$anchored_drive_name_regex/snap |
		 tr / ' ')
	set +f
	snapshot_sort_key=$#

	prev_date_time=
	for dir in $(list_drives | fgrep -v -w $drive_dir)
	    do	suspend_tracing
		echo $dir/$snapshot_pattern*
		restore_tracing
	done | tr ' ' '\n' | grep -v '\.rm$' |
	sort --field-separator=/ --key=$snapshot_sort_key |
	while read snapshot
	    do	date_time=$(basename $snapshot)
		date_time=${date_time%%.*}
		[[ $prev_date_time == $date_time ]] && continue
		    prev_date_time=$date_time

		cmd="copy_snapshot -p1 $snapshot $drive_name" # for debugging
		cmd="copy_snapshot -p0 $snapshot $drive_name"
		[[ $IfRun ]] && header $cmd
		$cmd || continue
		# break			# uncomment to debug
	done

	$IfRun sync --file-system $drive_dir &> /dev/null
	;;

  # snapshot-size dir: size of non-hard-linked files (ie in no other snapshots)
   ( snapshot*size | ss )
	[[ $# == 1 ]] || abort_with_action_Usage snapshot-size
	dir=$1
	[[ -d $dir ]] || abort "dir '$dir' doesn't exist"
	warn "this could take hours"
	$Trace
	KB=$(sudo find $dir -links 1 -printf '%k\n' |
		awk '{ total += $1 } ; END { print total }')
	set_readable_du_size $KB
	du_size=$readable_du_size
	echo "$dir contains >= $du_size of files in no other directories"
	;;

   # w: show pruning & backup activity, and the status of pruning and backups
   # watch [-f][-C][-N names] [watch opts]: 'watch w' (-f: wide; -C: cron jobs)
   ( watch | wa* | wt* | w )
	watch "$@"
	;;

   # kill-backup [-sig] name(s): for each name (can be 'all'), kill backup job
   ( kill-backup* | kb )
	[[ $# != 0 ]] || abort_with_action_Usage kill-backup
	$Trace
	kill_locker_group run-backup $*
	;;
   # kill-prune  [-sig] name(s): for each name (can be 'all'), kill prune job
   ( kill-prune* | kp )
	[[ $# != 0 ]] || abort_with_action_Usage kill-prune
	$Trace
	kill_locker_group prune-drive $*
	;;
   # kill-both   [-sig] name(s): for each name (can be 'all'), kill both jobs
   ( kill-both | ka | kk )
	[[ $# != 0 ]] || abort_with_action_Usage kill-both
	$Trace
	kill_locker_group   run-backup $*
	kill_locker_group prune-drive $*
	;;

   ###########################################################################
   # filesystem maintenance actions
   ###########################################################################

   ( add-extN-journal | aej )
     add_extN_journal "$@"
	;;

   ( dir*sizes | ds )
     dir_sizes "$@"
	;;

   ( mkfs )
     mkfs_backup_drive "$@"
	;;
   # copy-drive
   ( c*p*dr*v* | cpd )
     copy_backup_drive "$@"
	;;
   # finish-copy-drive
   ( f*c*p*dr*v* | f*c*p*d* | fcd )
     finish_copy_backup_drive "$@"
	;;
   # copy-drive-dump
   ( copy-dr*v*-dump )
     copy_backup_drive_with_dump "$@"
	;;

   ###########################################################################
   # Actions for random testing, followed by regression tests.
   ###########################################################################

   ( test | t )
	exit

	wont_trace() {         foo=2
		       suspend_tracing; echo untraced; restore_tracing foo; }
	will_trace() { set -x; foo=1
		       suspend_tracing; echo untraced; restore_tracing foo
		       wont_trace; echo traced; set +x; }
	will_trace
	exit

	log test 1
	customize_and_validate_configuration_variables Z
	echo $drive_name
	log test 2
	exit

	set_FS_block_size___from_path $1
	echo $FS_block_size
	exit

	for dev in $(df | cut -d' ' -f1)
	    do	[[ -b $dev ]] || continue
		set_FS_label___from_FS_device $dev
		echo "$dev -> $FS_label"
	done
	exit

	for path in /backup/A /backup/A/latest /dev/sdb5
	    do	set_FS_type___from_path $path
		echo "$path -> $FS_type"
	done
	exit

	print_call_stack 1
	abort test

	set_drive_name ${1:-a}
	TraceV 0 drive_name file_for_logging log_msg_prefix
	echo  test1
	echoE test2
	log 0 test3
	abort test4
	exit

	copy_snapshot 1 2 3
	exit

	echoE test
	foo() {
		echoE ftest
		for  i  in ${!FUNCNAME[*]}
		   do	echo "FUNCNAME[i]=${FUNCNAME[$i]}"
		done
		echoEV   i
		TraceV 0 i i
		abort "aborting test"
	}
	foo
	exit

	set_drive_name ${1:-a}
	set_drive_dir $drive_name
	set_FS_label___from_mount_dir $drive_dir
	echo $FS_label
	exit

	set_drive_dir ${1^}
	$Trace
	is_disk_usage_too_high
	abort $?

	set_oldest_snapshot
	echo $oldest_snapshot
	exit

	for size in 1023 1024 2123123 3123123123 4123123123123 5123123123123123
	    do	set_readable_du_size $size; echo "$readable_du_size from $size"
	done
	exit

	drive_dir=/backup/F
	cd $drive_dir
	log=/tmp/root/F-190126-15.bz2
	_links_error_msg "nnn 'Too many links'"
	exit

	set_drive_dir F
	exit

	$Trace
	set_drive_dir ${1-''}
	log "test with drive ${1-}"
	exit

	echo $backup_period
	customize_config_variables F
	echo $backup_period
	backup_period+=1
	echo $backup_period
	;;

   # mk-Z [date [period]]: create mostly-empty snapshot dirs in Z mount-point
   ( mk*[Zz] | mkz )
	[[ $1 == -q ]] && { is_quiet=$true; shift; } || is_quiet=$false

	# The following designed to work with (custom) configure.sh span of 1,
	#    and are memorialized in action test-prune.
	# Test pruning of hours: snapback mk-Z 12/22/2099 0..23 # 0, 2 seconds
	#    ...  days & months: snapback mk-Z 1/1/2094   0	 # 5,14 seconds
	#    ... months & years: snapback mk-Z 1/1/2010   month # 58,8 seconds

	# 1/1/2010 is earliest day, earlier days (e.g. 091231) look like octal
     readonly end_date="1/1/2100"	# keep constant, so can compare
	    start_date=${1:-12/22/2099}	# tests hours with ...
	        period=${2:-0..23}	# sequence of hours, else 'month'

	umask=02

	set_drive_dir Z
	cd_ $drive_dir
	[[ $IfRun ]] ||
	rm -rf *

	hours=00 is_months=$false
	case $period in
	    ( 0 ) ;;
	    ( month* ) is_months=$true ;;
	    ( * ) eval "set -- {$period}" ; hours=$* ;;
	esac

	declare -i start_secs=$(date -d "$start_date" '+%s')
	declare -i   end_secs=$(date -d   "$end_date" '+%s')
	declare -i secs=start_secs secs_per_day=24*60*60
	let end_secs-=3600		# end at 11 PM on previous day
	while  ((  secs < end_secs ))
	   do	set_day $secs
		secs+=secs_per_day
		[[ $day == *01 || ! $is_months ]] || continue
		[[ $day != 0* ]] || abort "start date must be after 1/1/2010"
		for hour in $hours
		    do	[[ $hour == ? ]] && hour=0$hour
			snapshot=$day,$hour
			[[ -d $snapshot ]] || echo $snapshot
		done
	done | xargs -r $IfRun mkdir || abort mkdir

	# setup partial snapshots mid-date, to test pruning
	declare -i mid_secs=start_secs+(end_secs-start_secs)/2
	set_day $mid_secs; mid_day=$day
	TraceV 7 start_date mid_day end_date
	for hour in 00 02 04 08 09 12
	    do	for ext in links partial
		    do	snapshot=$mid_day,$hour.$ext
			$IfRun mkdir -p $snapshot
		done
	done

	set_day $start_secs
	snapshot=$day,00
	for subdir in /var/repos/snap.test ~/{tmp,git/pylint}
	    do	bad_dir=$snapshot$subdir/deleteme
		$IfRun mkdir -p $bad_dir
		$IfRun touch    $bad_dir/deleteme.txt
	done
	[[ $is_quiet ]] ||
	Trace 0 "created excludable-junk in $snapshot"

	# there was something else that needed to be tested??
	for file in
	    do	true
	done

	$IfRun rm -rf .mk-Z
	$IfRun mkdir  .mk-Z	; [[ $IfRun ]] ||
	cp -al *    .mk-Z/
	;;

   # test-prune: use mk-Z to run pruning regression test in the Z pseudo-drive
   ( test*prune | tp )
	[[ $# == 0 ]] || abort_with_action_Usage test-prune

	[[ $UID != 0 ]] || abort "do not run this as root"

	customize_and_validate_configuration_variables Z

	cmd_dirs="/usr/local/bin/ ~/git/$_our_name/bin/"
	echo -e "\nComparing prune results using '$_our_name' in:
	${cmd_dirs/ / vs }"
	set_drive_dir Z

	# see the comment at the top of the mk-Z option, above
	declare -A prune_type2mk_Z_args=(
	      [hour]="12/22/2099 0..23"
	 [month-day]="1/1/2094 0"
	[year-month]="1/1/2010 month"
	)

	clone_stashed_mk_Z() {
		local type=$1 stash=.mk-Z.$1
		suspend_tracing
		rm -rf $snapshot_pattern* la* && cp -al $stash/* . ||
		   abort "failed to clone $stash"
		restore_tracing
	}

	$Trace
	cd_ $drive_dir
	for type in $(echo ${!prune_type2mk_Z_args[*]} | tr ' ' '\n' | sort)
	    do	mk_Z_args=${prune_type2mk_Z_args[$type]}
		header "prune '$type' snapshots, created by: mk-Z $mk_Z_args"
		stash=.mk-Z.$type
		$IfRun rm -rf $stash.*.ls
		[[ ! -d $stash ]] && {
		$IfRun $our_path mk-Z -q $mk_Z_args &&
		   $IfRun mv .mk-Z $stash && $IfRun rm -f $stash/latest ||
			abort "couldn't populate $stash"; }
		for dir in $cmd_dirs
		    do	eval "dir=$dir"	# expand ~
			$IfRun clone_stashed_mk_Z $type
			$IfRun $dir$_our_name $our_opts prune-drive Z |&
			   fgrep -v ' prune-drive Z: pruned '
			[[ $dir == /usr/* ]] && cmd=old || cmd=new
			ls > $stash.$cmd.ls
		done
		set -- $(echo $stash.*.ls | sort -r)
		diff -q $* && mv $stash.new.ls $stash.pruned.ls &&
			      rm $stash.old.ls &&
		   echo -e "\nSame results, see $stash*" && continue
		abort "Regression, see: diff $*"
	done

	clone_stashed_mk_Z hour
	echo -e "\nLeft a lot of unpruned snapshots in Z, for other testing."
	;;

   ###########################################################################
   # actions for snapcrypt to call
   ###########################################################################

   # WARNING: this should only be called by ourself or "snapcrypt close"
   # unmount name(s): for each name (can be 'all'), kill backup & unmount drive
   ( u*mount | u )			# umount
	[[ $# != 0 ]] || abort "pass name(s)"
	[[ $* == all ]] && set -- $(list_drives)

	$Trace
	# do this early, since takes a while for processes to die
	$IfRun $our_path $our_opts kill-both $*

	[[ $IfRun ]] && output=/dev/stdout || output=/dev/null
	for name
	    do	set_drive_name $name
		set_drive_dir $drive_name
		is_drive_mounted $drive_dir || continue
		/bin/ls $drive_dir |
		   grep "^$snapshot_regex" > $log_dir/$drive_name/snapshots.ls
		sudo umount -h &> /dev/null || warn "need sudo privs" || break
		umount_cmd="$IfRun sudo umount -v $drive_dir"
		for (( i = 1; i <= 30; i++ )) # wait for kill to finish
		    do	$umount_cmd && break
			$IfRun sleep 0.1
		done &> $output
		is_drive_mounted $drive_dir &&
		$umount_cmd		# this time, show user error message
	done
	;;
   # for "snapcrypt close": don't eject if didn't get any backups today
   ( has-new-snapshots | hsn )
	drive=$1
	[[ $drive == *Z ]] && exit 0	# for debugging

	$Trace
	is_drive_mounted $drive || exit 0
	suspend_tracing
	set -- $drive/$snapshot_pattern	# all the _successful_ snapshots
	restore_tracing
	latest_snapshot=${!#}
	[[ -d $latest_snapshot ]] ||
	    abort "$drive has no (successful) snapshots"
	latest_date_time=$(basename $latest_snapshot)
	latest_day=${latest_date_time%,??}
	# let latest_day=latest_day-1		# uncomment to debug
	set_date_time
	day=${date_time%,??}
	[[ $latest_day == $day ]] ||
	    abort "$drive has no (successful) backups since $latest_day"
	;;
   # for "snapcrypt close": find drive with max # snapshots since last mounted
   ( max-drive | max-backup* | md | mb )
	if [[ $# == 1 ]]
	   then set_drive_name $1 2>/dev/null
		if [[ ${drive_name-} ]]
		   then echo "$drive_dir_prefix$drive_name"
			exit 0
		fi
	fi

	set -- ${*:-$(list_drives)}	# for debugging: | tac
	[[ $# != 0 ]] || abort "no backup drives are mounted"

	declare -i secs_per_day=24*60*60
	$Trace
	max_drive=$1; shift
	while [[ $# != 0 ]]
	    do	new_drive=$1
		for (( secs=$(date '+%s'); 1; secs-=secs_per_day ))
		    do	set_day $secs

			set -- $new_drive/$day,??*
			[[ -d $1 ]] || break

			set -- $max_drive/$day,??*
			[[ -d $1 ]] && continue
			max_drive=$new_drive
			break
		done
		shift
	done
	echo $max_drive
	;;
   # for "snapcrypt": echo drive mountpoint
   ( drive )
	set_drive_name $1
	echo $drive_dir_prefix$drive_name
	;;

   ( * )
	abort "'$action' is not a recognized action, run: $_our_name -h"
	;;
esac

}

process_action "$@"
