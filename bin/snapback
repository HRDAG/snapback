#! /usr/bin/env bash

#     snapback is a utility to backup a system to multiple drives
#
#     Copyright (C) 2018-2019, Human Rights Data Analysis Group (HRDAG)
#     https://hrdag.org
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

version=17			# has to match version= in configure.sh.sample

###############################################################################
## Our naming and coding conventions are documented at the top of libsnap.sh ##
###############################################################################

# libsnap.sh has these functions/variables: $tmp_dir, $our_name, $our_path,
# $true, $false, have_cmd, need_cmds, $is_darwin, set_FS_type___from_path,
# set__inode_size__data_block_size__dir_block_size___from_path,
# $FS_label, set_FS_label___from_FS_device, label_drive,
# set_FS_device___from_FS_label, set_device_KB___from_block_device, $FS_device,
# set_FS_device___from_path, set_mount_dir___from_FS_device,
# set_mount_dir___from_FS_label,  set_FS_label___from_mount_dir,
# warn, abort, echoE, echoEV, Trace, TraceV, suspend_tracing, restore_tracing,
# print_or_egrep_Usage_then_exit, abort_with_action_Usage,
# log, $file_for_logging, $log_level, $log_msg_prefix, header,
# cd_ , confirm, is_arg1_in_arg2, run_function
#
# search for '####' in libsnap.sh to see environment and coding conventions
source libsnap.sh || exit 1


for dir in /usr/local/etc /etc; do [[ -d $dir/$our_name ]] && break; done
readonly   config_dir=$dir/$our_name
readonly exclude_file=$config_dir/exclude.txt
readonly  config_file=$config_dir/configure.sh

config_file_sample=$config_file.sample
if [[ $our_path == */$our_name/bin/$our_name ]]
   then git_home=$(dirname $(dirname $our_path))
	config_file_sample=$git_home$config_file_sample
fi ;						readonly config_file_sample

[[ -s $config_file_sample ]] ||
   abort "have to install $config_file_sample"

# for each config var, create associative array for per-drive customization
readonly uncustomizable_config_vars="
	     drive_dir_prefix old_crypt_name_prefixes drive_config_file
	     drive_name_regex admin_drive_name_regex is_drive_name_capitalized"
readonly config_vars=$(sed '/() *{/,/^}/d' $config_file_sample |
		       sed -n -r 's/^[^#=]*\b([^_]\w+)=.*$/\1/p' | sort -u)
for var in $config_vars; do eval "declare -A drv_name2$var"; done
#
# this grabs variables that control backup and pruning, and may also hold
# customizable functions set_drive_name & source_drive_specific_config_file
source $config_file || abort "$config_file broken"

[[     ${coder-} ]] ||			# custom version in $config_file?
readonly coder=sweikart@gmail.com

[[ -s $exclude_file ]] ||
   abort "install/edit $exclude_file, see included .sample"

Usage="
Usage: $our_name [options] action [args]
  Current actions are:
    list-drives [-a]: list mounted backup drives; -a adds drives cron ignores
    run-backups   names: backup names ('all' for every mounted backup drive)
    prune-drives  names: prune  names ('all' for every "" ""); see configure.sh
    update-drives [-d] [-s src-names-regex] dst-names: copy missing snapshots
    copy-snapshots [-d] [-q] snapshots name: copy to 'name' mounted drive

    snapshot-size dir: size of non-hard-linked files (ie in no other snapshots)
    w: show pruning & backup activity, and the status of pruning and backups
    watch [-f][-C][-N names] [watch opts]: 'watch w' (-f: wide; -C: cron jobs)

    ps [ps-opts] [type-pattern [name-pattern]]: show holders of lock(s)
    # -sig in kill-* defaults to -KILL (-9), i.e. terminates job & deletes lock
    kill-backup [-sig] names: for each name (can be 'all'), kill backup job
    kill-prune  [-sig] names: for each name (can be 'all'), kill prune job
    kill-copy   [-sig] names: for each name (can be 'all'), kill copy/update
    kill-all    [-sig] names: for each name (can be 'all'), kill all jobs

    add-extN-journal drive_name [FS_device [VG_name]]: fast external journal
    dir-sizes [-f | name]: generates stats for 'mkfs -b'; -f -> choose old file
    mkfs [-f] [mkfs-opts] device name: run mkfs optimized for many snapshots
    copy-drive {src_name | src_dev} dst_name [dst_dev]: duplicate backup drive
    filesystem-geometry [-a|-A|drive-dirs]: show sector, inode, block, etc

    check-snapshot-hard-links names: find snapshots with broken hard links
    mk-Z [date [period]]: create mostly-empty snapshot dirs in Z mount-point
    test-prune: use mk-Z to run pruning regression test in the Z pseudo-drive
    regression-test [tests]: check functionality, see $tmp_dir/?? for results

  NOTE: to see what an action would do, use -d option to simulate the action.

  Common options:
	-C: we are being run from cron

	-c: pass -c (--checksum) to rsync
	-n: pass -n (--dry-run ) to rsync
	-v: pass -v (--verbose ) to rsync (and maybe other commands)
	-q: pass -q (--quiet   ) to rsync (and maybe other commands)
	-r rsync-opt: pass rsync-opt to rsync

	-d: Debug shell script (don't run commands, just show them): simulation
	-t: Trace shell script (show commands as they execute)
	-T level: control whether Trace & TraceV functions run echoE & echoEV
"

is_cron=$false   cron_opt=
IfRun= Trace=    debug_opt= trace_opt=  our_rsync_opts=
our_opts=
while getopts "C cnvqr: dtT: hk"  arg
    do	our_opts+=" -$arg ${OPTARG-}"
	case $arg in
	   ( C ) is_cron=$true	cron_opt=-C ;;

	   ( c ) our_rsync_opts+=" --checksum"	;;
	   ( n ) our_rsync_opts+=" --verbose --dry-run" ;;
	   ( v ) our_rsync_opts+=" --verbose"	;;
	   ( q ) our_rsync_opts+=" --quiet"	;; # cancels --verbose
	   ( r ) our_rsync_opts+=" $OPTARG"	;;

	   ( d ) IfRun="echo -e" debug_opt=-d ;; # $IfRun prevents side-effects
	   ( t ) Trace="set -x"  trace_opt=-t ;;
	   ( T ) Trace_level=$OPTARG Trace_level_opt="-T $OPTARG" ;;

	   (h|k) print_or_egrep_Usage_then_exit "$@" ;;
	   ( * ) abort "$Usage" ;;
	esac
done
let OPTIND=$OPTIND-1
shift $OPTIND
unset arg

[[ $debug_opt ]] && verbose_opt=-v || verbose_opt=

[[ $Trace && $debug_opt ]] && IfRun=:

trap '' HUP TERM
trap 'set +x; rm -f $tmp_1 $tmp_2 $tmp_3 $tmp_4 $tmp_5; trap EXIT' EXIT

readonly tmp_1=$tmp_dir/$our_name-1-$$	; tmp=$tmp_1
readonly tmp_2=$tmp_dir/$our_name-2-$$
readonly tmp_3=$tmp_dir/$our_name-3-$$
readonly tmp_4=$tmp_dir/$our_name-4-$$
readonly tmp_5=$tmp_dir/$our_name-5-$$

need_cmds lockpid			# from libsnap repo

shopt -s extglob

umask 02				# log and lock dirs are setgid sudo/whatever

set -u					# abort if access unset variable

FUNCNEST=100				# catch coding errors

head -n1 $config_file_sample | fgrep -q -x "# version=$version" ||
  $IfRun abort "$config_file_sample version= does not match $our_path"

# $Trace

##############################################################################
# Miscellaneous variables used by for making and pruning backup snapshots.
##############################################################################

# touched when prune ends; its time is compared to files in $config_dir/
readonly pruned_timestamp=.pruned.ts

readonly our_opts=${our_opts# }
# need to fork and exec ourselves for session control with 'setsid'
readonly    run_backup_exe="$our_path $our_opts run-backup"
readonly   prune_drive_exe="$our_path $our_opts prune-drive"
readonly  update_drive_exe="$our_path $our_opts update-drive"
readonly copy_snapshot_exe="$our_path $our_opts copy-snapshot"

readonly hostname=${HOSTNAME%%.*}

readonly log_dir=/var/log/$our_name

file_for_logging=$log_dir/messages.log	     # set__drive_dir__* sets it
log_msg_prefix=' ${action-} ${drive_name-}' # this gets eval'ed each time

##############################################################################
# Miscellaneous functions used by for making and pruning backup snapshots.
##############################################################################

set_readable_du_size() {
	declare -i size=$1

	local suffix=K
	while (( $size >= 1024 ))
	   do	let size/=1024
		case $suffix in		# see: man du
		    ( 'K' ) suffix=M ;;
		    ( 'M' ) suffix=G ;;
		    ( 'G' ) suffix=T ;;
		    ( 'T' ) suffix=P ;;
		    ( 'P' ) suffix=E ;;
		    ( 'E' ) suffix=Z ;;
		    ( 'Z' ) suffix=Y ;;
		esac
	done
	readable_du_size=$size${suffix}B
}

# -----------------------------------------------------------------------------

assert_drive_dir_writable() {
	local dir=${1:-$drive_dir}

	[[ -f $dir ]] && dir=$(dirname $dir)
	$IfRun touch $dir/. ||
	   abort "$dir mounted read-only??  Maybe corrupted, run fsck."
}

##############################################################################
# lock management
##############################################################################

readonly lock_dir=/var/lock/$our_name

locks=
set_locks() {
	local type_regex=$1; shift
	local PIDs=$*

	[[ $PIDs ]] || return 1

	local cwd=$PWD
	cd $lock_dir || abort "cd $lock_dir"
	local fgrep_opts=$(echo " $PIDs" | sed 's/ / -e /g')
	set -- $(fgrep -l -w $fgrep_opts *.pid | egrep "$type_regex" |
		 sort | sed 's/\.pid//g')
	locks=$*
	cd $cwd

	[[ $locks ]]
}

# -----------------------------------------------------------------------------

sudo_lockpid=

set_sudo_lockpid() {

	[[ $sudo_lockpid ]] && return

	if [[ $action == kill-* ]] || sudo -n lockpid -h &> /dev/null
	   then sudo_lockpid="sudo lockpid --pid=$BASHPID"
	   else sudo_lockpid=lockpid  # only reclaim locks that user can write
	fi
	[[ $action == kill-* ]] && sudo_lockpid="$IfRun $sudo_lockpid"
	readonly sudo_lockpid
}

# --------------------------------------------

rm_stale_locks() {

	set_sudo_lockpid

	local lock_path
	for lock_path in $lock_dir/*.pid
	    do	[[ -e $lock_path ]] || continue
		$sudo_lockpid    $lock_path &> /dev/null &&
		$sudo_lockpid -r $lock_path
	done

	return 0
}

# -----------------------------------------------------------------------------

readonly lock_types="backup prune copy" # kill_all_jobs uses also

lock_path=				# used by lock() and signal_job()
set_lock_path() {
	local type=$1 name=${2:-$drive_name}

	[[ $name ]] || abort "$FUNCNAME: missing \$2 and \$drive_name null"
	lock_path=$lock_dir/$type-$name.pid
}

xtrace=				  # in case comment-out first line of function

lock_PID() {
	[[ -o xtrace ]] && { set +x; local xtrace="set -x"; } || local xtrace=
	[[ $1 == -n ]] && { local name=$2; shift 2; } || local name=$drive_name
	local lock_opts=
	while [[ $1 == -* ]] ; do lock_opts+=" $1"; shift; done
	local type=$1 lock_holder_action=$2

	is_arg1_in_arg2 $type $lock_types ||
	   abort "$FUNCNAME: '$type' is unknown lock type"
	set_lock_path $type $name
	local lock_file=$(basename $lock_path)

	[[ $lock_holder_action == holds* ]] ||
	    lock_holder_action="is $lock_holder_action"

	local our_PID=$BASHPID status_file=$tmp_3
	set -- lockpid --pid=$our_PID --dir=$lock_dir $lock_opts $lock_file
	local lock_cmd=$*
	local lockpid_output=$($IfRun $lock_cmd 2>&1; echo $? > $status_file)
	local status=$(< $status_file)
	rm $status_file

	if [[ $status == 0 ]]
	   then [[ $IfRun ]] &&
		echo "$lockpid_output" | sed "s@$our_PID@<our_PID>@"
		$xtrace
		return 0
	fi

	local lock_holder_PID=$(echo "$lockpid_output" |
				sed -r 's@.*rocess ([0-9]+) holds.*@\1@')
	if [[ $status == $lockpid_busy_exit_status && $lock_holder_PID ]]
	   then [[ ! $is_cron || $(date '+%H') == 00 || $log_level -gt 0 ]] &&
		log  "process $lock_holder_PID $lock_holder_action"
	   else log "$lock_cmd -> $lockpid_output (status=$status)"
	fi >&2
	$xtrace
	return 1
}

# ------------------------------------------------------------------

readonly lock_share_secs=0.5

declare -A _lock_type2lock_path
declare -A  lock_type2locked_resource

# Usage: lock [-w] type resource
#    Grab a lock of 'type' on resource (drive-dir or snapshot).
#    If -w and lock is held by other job, Wait for lock to be freed.
#    Can't grab 'prune' lock if 'backup' lock held and should suspend prune.
lock() {
	[[ ${action-} != test ]] && # [[ ${action-} != prune* ]] &&
	[[ -o xtrace  ]] && { set +x; local xtrace="set -x"; } || local xtrace=
	[[ $1 == -w   ]] && { shift; local do_wait=$true; } || local do_wait=
	[[ $1 != -*   ]] || abort "$FUNCNAME: unknown option $1, order matters"
	[[ $# == [12] ]] || abort "$FUNCNAME [-w] type resource"
	local type=$1 resource=${2:-$drive_name}

	local drive_name
	_set_drive_name $resource
	local drive_dir=$drive_dir_prefix$drive_name

	local prev_lock_path=${_lock_type2lock_path[$type]-}
	[[ ! $prev_lock_path ]] ||
	   abort "hold $(basename $prev_lock_path), can't grab $type lock file"

	local		    lock_msg="holds '$type' lock for $drive_name"
	local prunes_backup_lock_msg="${lock_msg/$type/backup}, so can't prune"
	[[ $type == prune ]] && lock_msg+=" (could be copy or update)"

	[[ $do_wait ]] && local wait_opt=--wait || local wait_opt=
	[[ $do_wait ]] &&
	if [[ $type == backup ]]
	   then declare -i half_backup_period_mins=$backup_period*60/2
		  if [[ $date_time == *-01,00 ]] # kept a very long time?
		   then wait_opt=--wait-expiration=15d # want it, or next month
		elif [[ $date_time == *-16,00 ]] # kept a long time?
		   then wait_opt=--wait-expiration=8d # want it, or next one
		elif [[ $date_time ==    *,00 ]] # kept a fairly long time?
		   then wait_opt=--wait-expiration=12h # want it, or tomorrow's
		   else wait_opt=--wait-expiration=${half_backup_period_mins}m
		fi
	elif [[ $type == prune && $action == prune* ]] # not update-drive?
	   then abort "if prune waits for prune lock, it suspends copy/update"
	fi

	while true
	    do	if [[ $type == prune && $suspend_prune_when_backup ]]
		   then # can't grab prune lock when backup is running
			lock_PID $wait_opt backup "$prunes_backup_lock_msg" &&
			lock_PID     -r    backup "$prunes_backup_lock_msg" ||
			    { $xtrace; return 1; } # not waiting, or expired
			if [[ $do_wait ]]
			   then if lock_PID -q prune "$lock_msg"
				   then break	 # success!
				   else lock_PID $wait_opt prune "$lock_msg" &&
					lock_PID     -r    prune "$lock_msg" ||
					   { $xtrace; return 1; } # expired
					continue # make sure no backup running
				fi
			#  else fall through
			fi
		fi

		lock_PID $wait_opt $type "$lock_msg" &&
		    break || { $xtrace; return 1; }
	done

	_lock_type2lock_path[$type]=$lock_path # lock_PID sets lock_path
	 lock_type2locked_resource[$type]=$resource

	 $xtrace
	return 0
}

# ---------------------------------

unlock() {
	[[ -o xtrace ]] && { set +x; local xtrace="set -x"; } || local xtrace=
	[[ $1 == -s ]] && { shift; local do_share=$true; } || local do_share=
	[[ $1 != -* ]] || abort "$FUNCNAME: unknown option $1"

	local type
	for type
	    do	local lock_path=${_lock_type2lock_path[$type]-}
		[[   $lock_path ]] || abort "don't hold lock of type '$type'"
		RunCmd lockpid -r $lock_path
		unset _lock_type2lock_path[$type]
		unset  lock_type2locked_resource[$type]
	done
	[[ $do_share ]] && $IfRun sleep $lock_share_secs
	$xtrace
}

##############################################################################
# enumerating/showing/signaling/killing process groups
##############################################################################

process_group_PIDs() {

	local PGID
	for PGID
	    do	# I don't know why this didn't work
		# ps -u root -o pid,pgid | grep " $PGID$" | awk '{ print $1 }'

		# "pstree -p -a" lines start with: <command>,<PID> ...
		pstree -p -a $PGID | sed 's/^[^,]*,\([0-9]*\).*/\1/'
	done
}

# ----------------------------------------------------------------------------

signal_is_kill=

set_signal_is_kill() {
	local signal=${1#-}

	case ${signal^^} in
	   ( SIGKILL | KILL | 9 )
		signal_is_kill=$true  ; return 0 ;;
	   ( *)	signal_is_kill=$false ; return 1 ;;
	esac
}

# ----------------------

signal_job() {
	local signal=${1#-} type=$2 name=${3-}

	suspend_tracing
	[[ $name ]] && set_drive_name $name
	restore_tracing
	name=$drive_name
	set_lock_path $type $name

	[[ -s $lock_path ]] || return 1
	set_sudo_lockpid
	[[ ! $debug_opt ]] &&
	$sudo_lockpid    $lock_path &> /dev/null && # missing or stale?
	$sudo_lockpid -r $lock_path && return 1

	set -- $(< $lock_path) && [[ $# != 0 ]] || return 1
	[[ $action == kill-prune ]] &&fgrep -s -w $1 ${lock_path/prune/copy} &&
	    { warn "ignoring $type-$name lock, held by copy job"; return 1; }
	$IfRun sudo kill -s ${signal^^} -$1 2> /dev/null || return 1

	set_signal_is_kill $signal &&
	$sudo_lockpid    $lock_path &> /dev/null && # avoid race
	$sudo_lockpid -r $lock_path

	return 0
}

# ---------------------------------

kill_jobs() {
	local type=$1; shift
	[[ $1 == -*  ]] && { local signal=${1^^}; shift; } ||local signal=-KILL
	[[ $1 != -*  ]] || abort "$FUNCNAME: unknown option $1"
	[[ $* == all ]] && set -- $(list_drive_dirs -a)

	local name status=1		# assume nothing to kill
	for name
	    do	signal_job $signal $type $name && status=0
	done

	return $status
}

# ---------------------------------

kill_all_jobs() {
	[[ $1 == -* ]] && { local opt=$1; shift; } || local opt=
	[[ $1 != -* ]] || abort "$FUNCNAME: unknown option $1"

	local type
	for type in $lock_types
	    do	kill_jobs $opt $type "$@"
	done
}

# -----------------------------------------------------------------------------

ps_locks() {
	[[ ${1-} == -R ]] && { local do_rm= ; shift; } || local do_rm=$true
	local ps_opts=
	while [[ ${1-} == -* || ${1-} == [^bcp] || $# -ge 3 ]]
	   do ps_opts+=" $1"; shift; done
	[[ $ps_opts   ]] || ps_opts="-o pid,stat,stime,command"
	[[ $is_darwin ]] || ps_opts="-H $ps_opts" no_header_opt=h
	local type_pattern=${1:-*} name_pattern=${2:-${drive_name:-*}}

	[[ ${is_drive_name_upper_cased-} ]] &&
	   name_pattern=${name_pattern^^}

	[[ $do_rm ]] && rm_stale_locks
	cd_ $lock_dir
	local status=1			# assume all locks are missing/stale
	eval "set -- $type_pattern*-$name_pattern.pid"
	for lock
	    do	header $PWD/$lock
		[[ -s $lock ]] || { echo "no such lock"; continue; }
		set -- $(< $lock)
		ps $ps_opts -$1 || ps ${no_header_opt-} $ps_opts $1
		status=$?
	done
	return $status
}

##############################################################################
# miscellaneous
##############################################################################

list_drive_dirs() {
	suspend_tracing
	[[ ${1-} == -a ]] &&
	   local list_all_drives=$true && shift ||
	   local list_all_drives=$false

	if [[ -t 0 || -t 1 || -t 2 || $list_all_drives ]]
	   then local regex=$admin_drive_name_regex
	   else local regex=$drive_name_regex # for cron & nohup
	fi
	[[ ${1-} == -A ]] && regex=/ || regex="^$drive_dir_prefix$regex$"
	df --output=target --no-sync -x devtmpfs -x tmpfs |
	   egrep "$regex" | sort -u
	restore_tracing
}

# ---------------------------------

is_drive_mounted() {
	local drive_dir=$1

	[[ $drive_dir ]] || return 1
	df | grep -q " $drive_dir$" || [[ $drive_dir == *[-/]Z ]]
}

# -----------------------------------------------------------------------------

function fix_snapshot_names {
	local drive_dir=$1

	set -- $drive_dir/$old_snapshot_pattern*
	[[ -d $1 ]] || return 0

	# this --kill -9 is completely safe
	$IfRun sudo fuser -k -9 -M $drive_dir
	local msg="$old_snapshot_pattern to $snapshot_pattern"
	log "renaming snapshots from $msg, first waiting ..."
	$IfRun sleep 5			# wait for kill

	local old_name
	cd_ $drive_dir
	for old_name in $old_snapshot_pattern*
	    do	[[ -d $old_name ]] || continue
		set_new_name $old_name
		$IfRun sudo mv $old_name $new_name || abort "need sudo privs"
	done
}

# ----------------------------------------------------------------------------

set_oldest_snapshot() {

	local oldest= FS
	for FS in $(list_drive_dirs)
	    do	suspend_tracing
		set -- $FS/$snapshot_pattern
		restore_tracing
		[[ $oldest && $(basename $oldest) < $(basename $1) ]] &&
		   continue
		oldest=$1
	done
	[[ -d $oldest ]] || abort "no old backup drives are mounted"
	oldest_snapshot=$oldest
}

##############################################################################-
# Setup variables for working with a specific backup drive.
##############################################################################-

drive_log_dir=

admin_group=

is_regression_test=$false

readonly none=NoNe
_last_fully_initialized_drive_name=

# this is normally called by set_drive_name; but you can pass
# a null drive_name to set default file_for_logging & drive_log_dir
set__drive_log_dir__file_for_logging__admin_group__is_regression_test() {
	local  drive_name=${1-}	     # called from set_drive_name, so $1 valid

	if  [[ $_last_fully_initialized_drive_name != ${drive_name:-$none} ]]
	   then _last_fully_initialized_drive_name=${drive_name:-$none}
	   else return 0		# skip very-long, duplicative setup
	fi

	if [[ $drive_name ]]
	   then drive_log_dir=$log_dir/$drive_name
	   else drive_log_dir=$log_dir
	fi
	TraceV 3 drive_log_dir
	file_for_logging=$drive_log_dir/messages.log

	suspend_tracing
	local user
	for user in ${SUDO_USER-} ${USER-} ${LOGNAME-} ${HOME##*/}
	    do	[[ $user != root ]] && break
	done
	local users_groups=$(id -G -n $user)
	local group
	for group in sudo wheel admin adm NoNe '' # 'admin' is Darwin / MacOS
	    do	is_arg1_in_arg2 $group $users_groups && break
	done
	[[ $group == NoNe ]] && group= || admin_group=$group
	restore_tracing group

	[[ -d $log_dir ]] || {
	sudo mkdir -p --mode=1777 $lock_dir
	sudo mkdir -p	   $log_dir	; [[ $group ]] &&
	sudo chgrp $group  $log_dir $lock_dir &&
	sudo chmod g+w,g+s $log_dir $lock_dir
	}
	[[ -d $log_dir ]] || abort "need sudo privs for initial setup"

	[[ $drive_name == Z ]] && is_regression_test=$true

	[[ $group ]] && group=:$group
	if [[ ! -d $drive_log_dir ]]
	   then sudo mkdir -p -m g+w,o-w $drive_log_dir
		[[ $is_regression_test ]] &&
		sudo touch $file_for_logging &&
		sudo chown $LOGNAME$group $drive_log_dir $file_for_logging
	fi
	[[ -d $drive_log_dir ]] || abort "need sudo privs to setup new drive"

	suspend_tracing
	customize_and_validate_configuration_variables $drive_name
	restore_tracing

	return 0
}

# ---------------------------------

drive_config_file=

have_cmd \
source_drive_specific_config_file ||  # configure.sh can replace this function
source_drive_specific_config_file() {
	[[ $# == 0 ]] && return
	local _name=$1  _main_config_file=${2:-${config_file-}}
	set_drive_name $_name
	[[ $_main_config_file ]] || abort "pass config_file as 2nd arg"

	local     _config_file=${_main_config_file/%.sh/-$drive_name.sh}
	if [[ -s $_config_file ]]
	   then drive_config_file=$_config_file	; source $_config_file
	   else drive_config_file=		; true
	fi
}

# ---------------------------------

drive_name=				# global, used by log() and etc

have_cmd \
_set_drive_name ||		      # configure.sh can replace this function
# ignore invalid names, fix the case of valid names
_set_drive_name() {
	local  name=${1#$drive_dir_prefix}
	name=${name%/$snapshot_pattern*}

	# needed when argument could be a drive_dir not a drive_name
	[[ $name =~ ^$admin_drive_name_regex$ ]] || return 1

	  if [[ $is_drive_name_upper_cased ]]
	   then drive_name=${name^^}
	elif [[ $is_drive_name_capitalized ]]
	   then drive_name=${name^}
	   else drive_name=$name
	fi
	_last_fully_initialized_drive_name= # prevent weird bugs
}

# ----------------------

have_cmd \
set_drive_name ||		      # configure.sh can replace this function
# pass: directory (that holds snapshots), filesystem label, or valid name
set_drive_name() {
	[[ $# == 1 && $1 ]] || abort "set_drive_name takes a single argument"

	local name=$1

	if [[ ! $name =~ ^$admin_drive_name_regex$ ]]
	   then if [[ $name == /dev/* ]]
		   then set_FS_label___from_FS_device $name
			set_mount_dir___from_FS_label $FS_label
			drive_dir=$mount_dir
		elif [[ $name != /* ]]
		   then set_mount_dir___from_FS_label $name
			drive_dir=$mount_dir
		   else drive_dir=$name
		fi
		[[  $drive_dir =~					\
		   ^$drive_dir_prefix$admin_drive_name_regex$ ]] ||
		   abort "$name is not drive-dir or FS-label or valid-name"
		name=${drive_dir#$drive_dir_prefix}
	fi
	_set_drive_name $name
	TraceV 3 drive_name

	set__drive_log_dir__file_for_logging__admin_group__is_regression_test \
	   $drive_name
}

# ---------------------------------

drive_dir=				# global, just in case

is_OK_if_drive_dir_unmounted=$false

set_drive_dir() {
	local drive_name=$1		# result of set_drive_name, i.e. valid

	[[ $drive_name != */* ]] ||
	  abort "'/' in drive name not (yet)supported, add to drive_dir_prefix"

	drive_dir=$drive_dir_prefix$drive_name

	if [[ $is_regression_test && ! -d $drive_dir ]]
	   then	[[ $admin_group ]] && local group=:$admin_group || local group=
		sudo mkdir $drive_dir &&
		sudo chmod g+s,g+w $drive_dir &&
		sudo chown $LOGNAME$group $drive_dir ||
		  abort "need sudo privs to setup pseudo-drive 'Z' for testing"
	fi

	if  is_drive_mounted  $drive_dir
	   then fix_snapshot_names $drive_dir # must call last
		sudo  -n  mkdir -p $drive_dir/.junk &> /dev/null # optional
	   else [[ $is_OK_if_drive_dir_unmounted ]] ||
		    warn "no filesystem mounted on $drive_dir" ||
		    : print_call_stack
		return 1
	fi

	return 0
}

# -----------------------------------------------------------------------------

custom_config_vars=

declare -A config_var2default_value

customize_config_variables() {
	local drive_name=${1-}

	[[ $drive_name ]] || return

	[[ $drive_name == Z ]] && is_regression_test=$true

	remember_tracing		# since suspend_tracing maybe not run
	local var_name
	[[ ${config_var2default_value[*]-} ]] ||
	for var_name in $config_vars
	    do	is_set $var_name ||
		   abort "need to set '$var_name=' in $config_file"
		config_var2default_value[$var_name]=${!var_name}
		suspend_tracing
	done
	restore_tracing

	# set__drive_log_dir__file_for_logging__admin_group__is_regression_test
	custom_config_vars="drive_log_dir file_for_logging"

	for var_name in config_file exclude_file
	    do	[[ $(declare -p $var_name) == "declare -r "* ]] ||
		custom_config_vars+=" $var_name"
	done

	for var_name in $config_vars
	    do	local array_name=drv_name2$var_name
		eval "local drv_names=\${!$array_name[*]}"
		[[ $drv_names ]] || continue
		suspend_tracing

		is_arg1_in_arg2 $var_name $uncustomizable_config_vars &&
		   abort "$config_file can't have custom '$var_name'"

		custom_config_vars+=" $var_name"

		is_arg1_in_arg2 $drive_name $drv_names ||
		   { eval "$var_name=\${config_var2default_value[$var_name]}"
		     continue; }

		eval "local custom_value=\${$array_name[\$drive_name]-}"
		eval "$var_name=\$custom_value"
		Trace 2 "$array_name[$drive_name] -> $var_name=$custom_value"
	done
	custom_config_vars=${custom_config_vars# }
	restore_tracing custom_config_vars
}

# ------------------------------------------------------------------

validate_config_variables() {

	declare -p $config_vars | grep -v '^declare -'
	[[ ${PIPESTATUS[0]} == 0 ]] ||
	    abort "must assign above variables, see $config_file_sample"

	local var=snapshot_date_time_separator
	[[ ${!var} == ',' ]] ||
	   abort "$var is not implemented, email $coder"
	#
	local var=extra_excludes
	[[ ! ${!var} ]] ||
	   abort "$var is not implemented, email $coder"
	#
	local bad_punctuation="[-.:0-9]" # you could ask $coder to change this
	[[ $snapshot_date_time_separator != *$bad_punctuation* ]] ||
	   abort "snapshot_date_time_separator can't contain $bad_punctuation"
	#
	[[ $excluded_backup_hours != *[^-\ \	0-9]* ]] ||
	   abort "excluded_backup_hours must be list of (ranges of) numbers"

	set -- $config_file $drive_config_file

	echo " $dirs_to_backup " | grep ' [^/]' &&
	   abort "dirs_to_backup contains a non-absolute path in $*"

	is_arg1_in_arg2 $backup_period $valid_backup_periods ||
	   abort "invalid 'backup_period=$backup_period' in $*"

	[[ -s $exclude_file ]] ||
	   abort "'exclude_file=$exclude_file' is empty file (from $*)"

	is_arg1_in_arg2 0 $successful_rsync_exit_statuses ||
	   abort "'successful_rsync_exit_statuses=$successful_rsync_exit_statuses' must contain 0 in $*"

	for var_name in drive_name_regex admin_drive_name_regex
	    do	# we'll anchor these variable's values ourselves, when needed
		[[ ${!var_name} != ^* ]] ||
		   abort "remove  leading '^' from $var_name="
		[[ ${!var_name} != *$ ]] ||
		   abort "remove trailing '$' from $var_name="
	done
}

# ------------------------------------------------------------------

customize_and_validate_configuration_variables() {
	local name=${1-}

	# avoid infinite loop
	set -- ${FUNCNAME[*]} ; shift
	is_arg1_in_arg2 $FUNCNAME $* && return

	suspend_tracing

	type -t source_drive_specific_config_file > /dev/null && # optional
	source_drive_specific_config_file $name

	customize_config_variables $name

	validate_config_variables	# must do this last

	restore_tracing
}

##############################################################################
# Manage priorities for backup and prune and update/merge.
##############################################################################

is_drive_usage_too_high() {

	suspend_tracing
	set -- $(df --output=pcent,ipcent $drive_dir | tail -n1)
	declare -i block_percent=${1%\%} inode_percent=${2%\%}
	restore_tracing
	(( $block_percent <= $min_FS_usage_percent )) || return 0
	(( $inode_percent <= $min_FS_usage_percent )) || return 0
	return 1
}

# -----------------------

setup_copy_priority() {

	$IfRun $cmd_to_set_copy_CPU_priority $BASHPID > /dev/null
	$IfRun $cmd_to_set_copy_IO_priority  $BASHPID > /dev/null
}

# --------------

setup_lower_priority() {

	$IfRun $cmd_to_set_lower_CPU_priority $BASHPID > /dev/null
	$IfRun $cmd_to_set_lower_IO_priority  $BASHPID > /dev/null
}

# --------------

setup_higher_priority() {

	$IfRun $cmd_to_set_higher_CPU_priority $BASHPID > /dev/null
	$IfRun $cmd_to_set_higher_IO_priority  $BASHPID > /dev/null
}

# -----------------------

# returns success if run at higher priority
setup_run_backup_priority() {

	if is_drive_usage_too_high
	   then  setup_lower_priority ; return 1
	   else setup_higher_priority ; return 0
	fi
}

# --------------

setup_prune_drive_priority() {

	if is_drive_usage_too_high
	   then setup_higher_priority
	   else  setup_lower_priority
	fi
}

# ---------------------------------

_backup_management_of_prune() {
	local state=$1

	[[ $is_cron ]] || return

	if [[ ( ! $suspend_prune_when_backup && $state ==  pre-rsync ) ||
	      (   $suspend_prune_when_backup && $state == post-rsync ) ]]
	   then $IfRun run_jobs_in_parallel prune $drive_dir
		return
	fi

	[[ $suspend_prune_when_backup && $state == pre-rsync ]] &&
	$IfRun signal_job SIGSTOP prune $drive_name
}

##############################################################################-
##############################################################################-
# Functions and variables used to prune old backup snapshots.
##############################################################################-
##############################################################################-

count_rsyncs_using_resource() {
	local regex=$*

	[[ $drive_name == Z || $IfRun ]] && return 0
	return $(COLUMNS=999 ps l -u root | egrep -c "\brsync .*$regex")
}

# -----------------------------------------------------------------------------

update_snapshots_ls() {

	echo $snapshot_pattern{,.links} | tr ' ' '\n' |
	    sort > $drive_log_dir/snapshots.ls
}

# -----------------------------------------------------------------------------

_is_time_to_prune_drive() {
	local dir=$1

	[[ ! $is_cron ]] && return 0	# run by a person?

	[[ $(date '+%H') == 00 ]] && return 0 # time for our daily prune?

	set -- $dir/*.rm
	[[ -d $1 ]] && return 0		# have partially-deleted snapshots?

	local pruned_TS=$dir/$pruned_timestamp

	[[ ! -e $pruned_TS ]] && return 0 # never finished a prune?
	[[ $pruned_TS -ot $config_file   ]] && return 0 # newer config?
	[[ $pruned_TS -ot $exclude_file  ]] && return 0 # newer excludes?
	[[ $(find $pruned_TS ! -mtime 0) ]] && return 0	# not pruned recently?

	return 1			# not time to prune
}

# ----------------------

_rm_pruned_snapshots() {
	local snapshots_file=$1

	local snapshot

	assert_drive_dir_writable $PWD

	suspend_tracing
	set -- $(< $snapshots_file)
	rm $snapshots_file

	[[ $# != 0 && ! $is_update ]] &&
	if (( $log_level >= 2 ))
	   then [[ $debug_opt ]] ||
		log "will prune these snapshots: " $*
	   else $IfRun \
		log "pruning $# snapshots: will rename to *.rm for deletion"
	fi

	[[ $is_update && $debug_opt ]] && local sudo=sudo || local sudo=

	# first, rename snapshots to be pruned, so can see the pruning backlog
	for snapshot
	    do	count_rsyncs_using_resource  $snapshot || continue # in use?
		[[ $snapshot != *.rm && ! -e $snapshot/.keep ]] &&
		[[ -e $snapshot ]] || continue
		if [[ $is_update ]]
		   then  $sudo mv $verbose_opt $snapshot $snapshot.rm
		   else $IfRun mv	       $snapshot $snapshot.rm
		fi
	done

	if [[ $is_update ]]
	   then set -- *.partial.rm	# some from update, some from pruning
		[[ -d $1 ]] && $sudo rmdir --ignore-fail-on-non-empty $*
		restore_tracing
		return
	fi

	update_snapshots_ls

	set -- $snapshot_pattern*.rm
	[[ -d $1 ]] || shift
	local snapshot_basenames=$*
	restore_tracing

	if [[ ! -d latest ]]
	   then set -- $snapshot_pattern # only the successful snapshots
		[[ -d ${!#} ]] && $IfRun rm -f latest &&
		$IfRun ln -s $(basename ${!#}) latest
	fi

	suspend_tracing
	# put newest ones first, since they have the most hardlinks.
	# use absolute paths, so the 'ps' output is more clear.
	set -- $(echo $drive_dir/*.rm | tr ' ' '\n' | sort -r)
	[[ -d $1 ]] || shift
	local number_pruned_snapshots=$#
	restore_tracing number_pruned_snapshots

	$Trace
	# just prune subdirs containing files with massive # of hard-links;
	# except too-high drive usage is more critical than "Too many files".
	set_FS_type___from_path $PWD
	case ${FS_type,,} in
	    ( xfs | btrfs )		# any FS that supports a zillion links
		hard_link_dirs= ;;
	esac
	[[ ${hard_link_dirs-} ]] && ! is_drive_usage_too_high $drive_dir &&
	for snapshot
	    do	local subdir
		for subdir in $hard_link_dirs
		    do	$IfRun rm -rf $snapshot$subdir
		done
		suspend_tracing
	done
	restore_tracing

	# finally, prune the rest of the contents of the *.rm snapshots
	for snapshot
	    do	$IfRun rm -rf $snapshot
		suspend_tracing
	done
	restore_tracing

	(( $number_pruned_snapshots > 0 )) &&
	if (( $log_level >= 3 ))
	   then [[ $debug_opt ]] ||
	        log "deleted these pruned snapshots: $snapshot_basenames"
	   else $IfRun \
		log "deleted $number_pruned_snapshots *.rm pruned snapshots"
	fi

	local pruned_TS=$drive_dir/$pruned_timestamp
	[[ $drive_name == Z ||		# regression test?
	   ( ! $debug_opt &&		# ... too slow for real drive
	     # very slow: only run if exclude.txt changed since our last run
	     ( ! -e $pruned_TS ||
		    $pruned_TS -ot $exclude_file ) ) ]] &&
	{
	# prune exclude-patterns from _all_ snapshots, very slow
	local exclude_pattern file
	for snapshot in $drive_dir/$snapshot_pattern*
	    do	[[ $snapshot == *.rm ]] && continue
		grep '^ */' $exclude_file | fgrep -v '**' |
		while read exclude_pattern
		    do	set -- $snapshot$exclude_pattern
			for file	# can have SPACEs, need to quote it
			   do	[[ -e "$file" ]] && echo "$file"
			done
		done
		suspend_tracing
	done | tr '\n' '\0' | xargs -0 -r $IfRun rm -r # -0: files with SPACEs
	}
	restore_tracing

	$IfRun log "pruned exclude-patterns from _all_ snapshots"

	$IfRun sync --file-system $drive_dir &> /dev/null # maybe not supported
}

# ------------------------------------------------------------------------------------
# variables and functions that implement the snapshot date-time format, and pruning) #
# ------------------------------------------------------------------------------------

# snapshot basename format is Year-Mo-Da,Hr, all implemented in this section;
#    to implement snapshot_date_time_separator, search for: ,00 ,?? ,$ ,/

#			       _Year_MoDa-Hr
readonly old_snapshot_pattern="[1-9]?????-??"
readonly     snapshot_pattern="[1-9][0-9][0-9]?-??-??,??" # Year-Mo-Da,Hr
readonly max_snapshot_pattern="9999-12-31,23"		  # max supported value
readonly snapshot_day_pattern=${snapshot_pattern%,??}	  # Year-Mo-Da
set_new_name() { new_name=$(echo $1 | sed -r 's/-/,/;s/^(..)(..)/20\1-\2-/'); }
readonly     snapshot_regex=${snapshot_pattern//\?/.}
readonly snapshot_day_regex=${snapshot_regex%,??}

set_date_time() { date_time=$(date '+%Y-%m-%d,%H' "$@"); }
set_day      () {       day=$(date '+%Y-%m-%d' -d "@$1" ); }
set_seconds  () {   seconds=$(date '+%s'       -d "$(basename $1 |
				        sed 's/\..*//;s/,/ /;s/$/:00:00/')" ||
				warn "$FUNCNAME: can't parse $1"; ); }

# --------------------------------------------

shorten_date() {
	case $1 in
	    (  hour ) sed 's/,..$//' ;;	# strip time from snapshot's date-time
	    (   day ) sed 's/-..$//' ;; # strip day from snapshot's date
	    ( month ) sed 's/-..$//' ;; # strip month from year-month
	    (  year ) sed   's/.$//' ;; # turn year into decade
	esac | uniq
}

declare -A type2date_suffix_pattern=(
	 [NONE]=""
	 [hour]=",??"
	  [day]="-??,??"
	[month]="-??-??,??"
	 [year]="?-??-??,??"
)
[[ ${snapshot_pattern%${type2date_suffix_pattern[year]}} != \
   "$snapshot_pattern" ]] ||
	abort "snapshot_pattern has to end with type2date_suffix_pattern[year]"

set_prune_pattern() {
	local type=$1 pattern=$2

	local date_suffix_pattern=${type2date_suffix_pattern[$type]}
	local date_prefix_pattern=${snapshot_pattern%$date_suffix_pattern}
	case $type in
	   (  hour ) local date_suffix_type=NONE  ;;
	   (   day ) local date_suffix_type=hour  ;;
	   ( month ) local date_suffix_type=day   ;;
	   (  year ) local date_suffix_type=month ;;
	esac
	date_suffix_pattern=${type2date_suffix_pattern[$date_suffix_type]}
	prune_pattern=$date_prefix_pattern$pattern$date_suffix_pattern{,.*}
}

readonly valid_backup_periods="1 2 4 8 12 24" # also in configure.sh comment

declare -A backup_period2minimal_snapshot_pattern=(
    [1]="$snapshot_pattern"
    [2]="$snapshot_day_pattern,?[02468]"
    [4]="$snapshot_day_pattern,{[02][048],1[26]}"
    [8]="$snapshot_day_pattern,{00,08,16}"
   [12]="$snapshot_day_pattern,{00,12}"
   [24]="$snapshot_day_pattern,00"
)
#
# the [hour] chunks are the complement of the previous map's values
[[	 ${type2prune_type_patterns-} ]] || # custom version in $config_file?
declare -A type2prune_type_patterns=(
# the ones these patterns skip: hour=00, day=01, month=01, year=00
# period after prune: 2                4                 ~8          ~12   all
   [hour]=",?[13579]         ,{[02][26],1[048]}       ,{04,20}    ,{08,16} ,12"
    [day]="-{?[3579],[1-3]1} -{[02][26],1[048],30} -{04,12,20,28} -{08,24} -16"
  [month]="-{0[3579],11}          -{02,08,12}         -{04,10}       -06"
   [year]="  [13579]                 {2,6}              {4,8}"
)

function load__type2date_span {

    type2date_span=(
	 [hour]=$days_per_span_for_hour_prune
	  [day]=$months_per_span_for_day_prune
	[month]=$years_per_span_for_month_prune
	 [year]=$decades_per_span_for_year_prune
    )
}

# -------------------------------------------------------------------------------------------
# end of variables and functions that implement the snapshot date-time format, and pruning) #
# -------------------------------------------------------------------------------------------

declare -A backup_period2minimal_snapshot_regex
#
for _period in ${!backup_period2minimal_snapshot_pattern[*]}
    do	  value=${backup_period2minimal_snapshot_pattern[$_period]}
	value=${value//\?/.}
	value=${value//\{/(}
	value=${value//\}/)}
	value=${value//,/|}
	value=${value/|/,} 		# restore $snapshot_date_time_separator
	backup_period2minimal_snapshot_regex[$_period]=$value
done
unset _period

scale_date_span() {

	date_span=$( echo "$date_span $pruning_span_scale_factor" |
		     awk '{ printf "%.0f\n", $1 * $2 }' )
}

_oldest_snapshot=

prune_type_to_file() {
	local type=${1%s} file_of_snapshots_to_prune=$2; shift 2
	set -- $(echo $* | tr ' ' '\n' | cut -d. -f1 | shorten_date $type)
	local remaining_reverse_sorted_snapshot_dates=$*

	declare -A type2date_span
	load__type2date_span	# run after call to customize_config_variables
	local date_span=${type2date_span[$type]}
	scale_date_span
	local prune_type_patterns=${type2prune_type_patterns[$type]}
	local date_suffix_pattern=${type2date_suffix_pattern[$type]}
	[[ $type == hour ]] && _oldest_snapshot=$drive_dir/${!#},00

	Trace 5 "\n==> $type prune <=="
	declare -i period=$backup_period
	local prune_pattern
	while set_popped_word___from_list prune_type_patterns
	    do	local prune_type_pattern=$popped_word
		set -- $remaining_reverse_sorted_snapshot_dates

		# might want to delete *all* the snapshots left to be pruned
		if [[ $date_span == 0 ]]
		   then shift	      # don't delete span we previously pruned
			for date
			    do	echo $date*
			done
			break

		fi

		Trace 4 "\n  LOOP $type: $# dates left: ${1-} ${2-} ... ${!#}"
		! _do_skip_newest_span_of_days $type || shift $date_span ||
		    shift $# # shift does nothing if try to shift more than $#
		remaining_reverse_sorted_snapshot_dates=$*
		local first_prune_date=${1-}
		[[ $first_prune_date ]] || break

		set_prune_pattern $type $prune_type_pattern
		TraceV 5 date_suffix_pattern first_prune_date \
			  prune_type_pattern prune_pattern
		eval "set -- $prune_pattern"
		[[ -d $1 ]] || shift
		Trace 5 "\n Matched  $# snapshots: ${1-} ${2-} ${3-} ... ${!#}"

		# skip over the snapshot prune-matches that aren't old enough
		set -- $(echo $* | tr ' ' '\n' | sort -r)
		while [[ $# != 0 ]]
		   do	[[ $1 == $drive_dir/[^1-9]* ]] && shift && continue
			local day_hour=${1##*/}
			local date=${day_hour%$date_suffix_pattern*}
			[[   $date > $first_prune_date ]] || break
			shift
		done
		[[ -d ${1-} ]] || continue
		# delete all the old-enough prune matches
		Trace 5 "\nDeleting ~$# snapshots: $1 ${2-} ${3-} ... ${!#}"
		echo ${*%$_oldest_snapshot*} # don't delete oldest snapshot
	done >> $file_of_snapshots_to_prune

	echo $remaining_reverse_sorted_snapshot_dates
}

# ----------------------

_do_skip_newest_span_of_days() {
	local type=$1

	[[ $type != hour* ]] && return 0

	# if $backup_period had been too short and we lengthened it,
	#   we delete recent snapshots that "shouldn't" have been created,
	#   by not shifting remaining-days until we've pruned the "spurious"
	if   (( period <=  1 )) ; then return 0
	elif (( period <=  2 )) ; then period=1
	elif (( period <=  4 )) ; then period=2
	elif (( period <=  8 )) ; then period=4
	elif (( period <= 24 )) ; then period=8
				  else period=24
	fi
	Trace 5 "period now $period, didn't shift"
	return 2			# higher than 'shift' error status
}

# ---------------------------------------------------------

# for goals of this function, see prune-variable comments in configure.sh
prune_drive() {
	[[ $1 == -u ]] && { local is_update=$true; shift; } || local is_update=
	[[ $1 != -* ]] || abort "$FUNCNAME: unknown option $1"
	local drive_name=$1 drive_dir

	suspend_tracing
	set_drive_name $drive_name
	set_drive_dir  $drive_name || return 1
	restore_tracing

	[[ $UID == 0 || $is_regression_test ]] || $IfRun abort "run with sudo"

	[[ ! $is_update ]] && {		# for update, we just rmdir empty dirs

	# if use suspend, priority is "which job should run" not renice/ionice
	if is_drive_usage_too_high && [[ $suspend_prune_when_backup ]]
	   then local lock_opt=	  # desparately need pruning, borrow copy lock
	   else local lock_opt=
	fi
	# lock_opt+=" -w"	    # this would keep copy or update suspended

	lock $lock_opt prune ||
	    # since we're called, the old lock holder should be un-suspended
	    { signal_job SIGCONT prune $drive_name; return 1; }

	_is_time_to_prune_drive $drive_dir || { unlock prune; return 0; }

	trap '' HUP
	setup_prune_drive_priority

	}

	$Trace
	local  snapshots_to_prune_file=$tmp_4
	rm -f $snapshots_to_prune_file

	cd_ $drive_dir	# so can safely kill job with: fuser -k -M $drive_dir

	# set -- <all the snapshot basenames, reverse sorted>
	suspend_tracing
	set -- $(cd $drive_dir &&
		   echo $snapshot_pattern*  | # prune everything
		   tr ' ' '\n' | sort -u -r |
		   grep -v '\.rm$')	# _rm_pruned_snapshots handles *.rm
	restore_tracing
	# prune_type_to_file returns dates remaining, to check for more pruning
	set -- $(prune_type_to_file hour  $snapshots_to_prune_file $*)
	set -- $(prune_type_to_file day   $snapshots_to_prune_file $*);#$Trace
	set -- $(prune_type_to_file month $snapshots_to_prune_file $*);#set +x
	set -- $(prune_type_to_file year  $snapshots_to_prune_file $*)

	_rm_pruned_snapshots $snapshots_to_prune_file # it deletes the file
	rm -f $snapshots_to_prune_file

	[[ $is_update ]] && return

	$IfRun touch $drive_dir/$pruned_timestamp # touch even if did nothing

	unlock prune
}

##############################################################################-
##############################################################################-
# Functions and variables used to create new backup snapshots.
##############################################################################-
##############################################################################-

# -----------------------------------------------------------------------------
# functions to setup --link-dest args to rsync
# -----------------------------------------------------------------------------

_have_full_snapshot() {

	set -- ${new_snapshot%/$snapshot_pattern*}/$snapshot_pattern
	[[ -d $1 ]]
}

# ---------------------------------

declare -i num_link_dests=0

set_link_dest_opts() {
	local new_snapshot=$1; shift

	while [[ ! -d ${1-} || ${1-} == $new_snapshot* ]]
	   do	[[ $# != 0 ]] || return	# we might not have any snapshots
		shift
	done
	[[ -d ${1-} ]] || return

	# need at least 2 --link-dest args in case the sysadmnin borked one,
	# and a few hours worth in case a file was deleted then recovered;
	# don't make this too large, it slows recovery from "Too many links"
	if (( $backup_period == 1 ))
	   then num_link_dests=4
	   else num_link_dests=2
	fi

	suspend_tracing
	declare -i goody_snapshots=0 links_snapshots=0 junky_snapshots=0
	_have_full_snapshot || junky_snapshots=-10 # big src, slow/flakey dst?
	local snapshot
	for snapshot
	    do	[[ -d  $snapshot ]] || continue
		set -- $snapshot/*
		[[ -d  $1 ]] || continue # update's empty snapshot?
		# don't consider *.partial or *.links to be adequate;
		# 20 --link-dest options max (10 per direction)
		case $snapshot in
		    ( *.links ) (( ++links_snapshots > 3 )) && continue ;;
		    ( *.*     ) (( ++junky_snapshots > 2 )) && continue ;;
		    (  *      ) (( ++goody_snapshots > $num_link_dests )) &&
					break ;;
		esac
		link_dest_opts="$link_dest_opts --link-dest=$PWD/$snapshot"
	done
	restore_tracing link_dest_opts
}

# ------------------------------------------------------------------

set_link_dest_opts___for_run_backup() {
	local new_snapshot=$(basename $1)

	suspend_tracing
	# want the .links snapshots too, so quickly recover from
	#    'Too many links' by just copying the file
	# want a .partial to get the latest stuff, but won't "count" it
	set -- $(echo $snapshot_pattern{,.links,.partial} |
		 tr ' ' '\n' | sort -r)
	restore_tracing

	set_link_dest_opts $new_snapshot $*
}

# ------------------------------------------------------------------

set_link_dest_opts___for_copy_snapshot() {
	local new_snapshot=$(basename $1)

	suspend_tracing
	# want the .links snapshots too, so quickly recover from
	#    'Too many links' by just copying the file
	# want a .partial to get the latest stuff, but won't "count" it
	set -- $(echo $snapshot_pattern{,.links,.partial} |
		 tr ' ' '\n' | sort -r |
		 while  read  snapshot
		    do	[[   $snapshot < $new_snapshot ]] || continue
			echo $snapshot
		 done)
	restore_tracing
	set_link_dest_opts $new_snapshot $* # newest to oldest

	set -- $(echo $snapshot_pattern{,.links,.partial} |
		 tr ' ' '\n' |
		 while  read  snapshot
		    do	[[   $snapshot > $new_snapshot ]] || continue
			echo $snapshot
		 done)
	restore_tracing
	set_link_dest_opts $new_snapshot $* # oldest to newest
}

# -----------------------------------------------------------------------------
# misc functions to support run_rsync
# -----------------------------------------------------------------------------

set_hours() {
	local var_name=$1

	set -- $(
	for hour in ${!var_name}
	    do	[[ $hour =~ ^0+$ ]] && continue # pruning needs midnight backup
		[[ $hour == *-*  ]] || { echo $hour; continue; }
		[[ $hour != *-*-* ]] || abort "bad $var_name range"
		first=${hour%-*} last=${hour#*-}
		if (( $first <= $last ))
		   then eval echo \{$first..$last\}
		   else eval echo \{$first..23\} \{1..$last\}
		fi
	done
	)
	hours=$*
}

# ---------------------------------

_is_time_to_run_backup() {
	local dir=$1

	[[ ! $is_cron ]] && return 0	# run by a person?

	local current_hour=$(date '+%k') hours
	set_hours excluded_backup_hours
	is_arg1_in_arg2 $current_hour $hours && return 1
	(( $current_hour % $backup_period == 0 )) && return 0

	return 1
}

# -------------------------------------------------------

readonly rsync_time_subdir=stats/rsync-minutes

[[	 ${days_to_keep-} ]] ||		# custom version in $config_file?
declare -i days_to_keep=3		# ensure more than weekend-only data

record_rsync_time() {
	local snapshot=$(basename $1)
	declare -i start_secs=$2

	declare -i end_secs=$(date '+%s')
	declare -i minutes=$(( (30 + $end_secs - $start_secs) / 60 ))

	local file=$drive_log_dir/$rsync_time_subdir/$snapshot.txt
	$IfRun mkdir -p $(dirname $file)
	local link=$log_dir/$rsync_time_subdir/$drive_name
	$IfRun mkdir -p $(dirname $link)
	[[ -e $link ]] ||
	$IfRun ln -s ../../$drive_name/$rsync_time_subdir $link

	local cmd="echo $minutes > $file"
	if [[ $debug_opt ]]
	   then echo "$cmd"
	   else eval "$cmd"
	fi || return 1

	declare -i number_files_per_day=24/$backup_period
	declare -i number_files_to_keep=$number_files_per_day*$days_to_keep
	set -- $(dirname $file)/$snapshot_pattern.txt
	while (( $# > $number_files_to_keep ))
	    do	$IfRun rm $1
		shift
	done
}

# -------------------------------------------------------

_links_error_msg() {
	local msg=$*

	# since contents of $() are run in subshell, have to echo results
	declare -i max_src_links=$(
	declare -i max_src_links=0
	bzcat $log | tr -d '"' | cut -d' ' -f3 |
	while read dst_file
	    do	src_file=${dst_file#$drive_dir/$snapshot_pattern.partial}
		[[ -f $src_file ]] || continue
		set -- $(ls -l $src_file)
		((   $max_src_links >= $2 )) && continue
		      max_src_links=$2
		echo $max_src_links
	done | tail -n1
	)

	declare -i link_dest_wait=$(( num_link_dests * backup_period ))
	set -- *.rm
	msg="$msg; Worst case, tried to add $max_src_links links to a snapshot file; these files will eventually appear in a new snapshot after $link_dest_wait hours; $# snapshots waiting to be pruned, newer prunes subtract ~$max_src_links links"

	[[ $hostname != eleanor ]] &&
	msg="$msg; Edit prune variables in $config_file to reduce # snapshots"

	echo "$msg"
}

# ---------------------------------

_handle_rsync_results() {
	local new_snapshot=$1 status=$2 log=$3

	if [[ -s $log ]]
	   then [[ ${is_interactive-$IfRun} ]] && { bzcat $log; rm $log; }
	   else rm -f $log
	fi

	# uncomment next line to debug link_fail_count code with -d option
	# echo 'link failed: Too many links (31)' | bzip2 >> $log; status=31

	local error_msg=

	if is_arg1_in_arg2 $status "$successful_rsync_exit_statuses"
	   then $IfRun mv $new_snapshot.partial $new_snapshot &&
		[[ $new_snapshot != *.links ]] &&
		set -- $snapshot_pattern &&
		$IfRun rm -f latest && $IfRun ln -s ${!#} latest &&
		update_snapshots_ls
		[[ ! $is_copy_snapshot ]] && # time used to set backup_period
		record_rsync_time $new_snapshot $start_seconds
		[[ $new_snapshot == *,00 || $log_level -gt 0 ||
		   ! $is_cron || $debug_opt ]] &&
		$IfRun log "created $new_snapshot (at ${priority}er priority)"
	   else set -- $(bzcat $log 2>/dev/null | # might be empty file
			 grep -c ': Too many links (31) *$')
		local  link_fail_count=$1 # see test, above
		if (( $link_fail_count == 0 ))
		   then local err=$(bzcat $log | tail -n2)
			((  $(echo "$err" | wc -l) > 1 )) &&
			err=$(echo "$err" | sed '1s/.*: //' |
						tr '\n' '|' | sed 's/|/; /')
			error_msg="...; ${err}rsync exit status=$status"
		   else error_msg="$link_fail_count 'Too many links'"
			error_msg=$(_links_error_msg "$error_msg")
			$IfRun mv $new_snapshot.partial $new_snapshot.links
			record_rsync_time $new_snapshot $start_seconds
		fi
		if is_arg1_in_arg2 $status "$no_log_rsync_exit_statuses" ||
		   (( $(bzcat $log | wc -l) == 0 ))
		   then rm -f $log
			error_msg="$error_msg; Partial snapshot still useful"
		   else error_msg="$error_msg; See $log"
		fi
	fi

	if [[  $error_msg ]]
	   then	[[ $Trace || $drive_name == Z ]] && # Z = debug "drive"
		log "$error_msg" ||
		log "$error_msg" |& tee -a /dev/stderr | sed 's/; /\n/g' |
		   $IfRun mail -s "$our_name: errors" $sysadmin_email_addresses
	   else rm -f $log
	fi
}

# ----------------------

run_rsync() {
	if [[ $1 == -c ]]
	   then shift
		local is_copy_snapshot=$true
	   else local is_copy_snapshot=$false
	fi
	[[ $1 != -* ]] || abort "$FUNCNAME: unknown option $1"
	local dst_snapshot=${!#}
	local src_dirs=${*%$dst_snapshot}

	local date_time=$(basename $dst_snapshot)
	local log=$tmp_dir/$drive_name-${date_time%%.*}.bz2

	[[ $UID == 0 || $is_regression_test ]] || $IfRun abort "run with sudo"

	assert_drive_dir_writable $(dirname $dst_snapshot)

	if [[ $dst_snapshot == *.partial ]]
	   then local partial_dst=$dst_snapshot
	   else local partial_dst=$dst_snapshot.partial
		# if we (partially) created this snapshot earlier, reuse it
		local suffix
		for   suffix in '' '.links'
		    do	local  useful_dst=$dst_snapshot$suffix
			[[ -d $useful_dst ]] &&
			   $IfRun mv $useful_dst $partial_dst && break
		done
	fi

	[[ ! $is_copy_snapshot ]] &&   # copy keeps original mtime
	{		     # ensure $dst_snapshot has current time
	[[ $debug_opt ]] ||  # use 'sleep 9' to wait for rsync to modify mtime
	until [[ -e  $partial_dst || -e $dst_snapshot ]] ; do sleep 9; done
	$IfRun touch $partial_dst	# in case we crash; see next 'touch'
	[[ -f $partial_dst ]] && rm $partial_dst # quick backup??
	} &

	suspend_tracing
	local link_dest_opts=
	if [[ ! $is_copy_snapshot ]]
	   then set_link_dest_opts___for_run_backup    $dst_snapshot
	   else set_link_dest_opts___for_copy_snapshot $dst_snapshot
	fi
	restore_tracing link_dest_opts

	# drive_dir_prefix and rsync_backup_opts come from $config_file
	local relative_opt= excludes=
	[[ ! $is_copy_snapshot ]] &&
	relative_opt=--relative  excludes="--exclude=$drive_dir_prefix*
					   --exclude-from=$exclude_file"
	declare -i start_seconds=$(date '+%s')

	$Trace
	$IfRun rsync $rsync_backup_opts	\
		     $our_rsync_opts	\
		     $relative_opt	\
		     $link_dest_opts	\
		     $excludes		\
			$src_dirs $partial_dst/ |& bzip2 -9 > $log
	local status=${PIPESTATUS[0]}	# https://stackoverflow.com/a/20738063

	[[ ! $is_copy_snapshot ]] &&
	$IfRun touch $partial_dst	# 'when we finished', not mdate of src

	_handle_rsync_results $dst_snapshot $status $log

	$IfRun sync --file-system $dst_snapshot* &> /dev/null # optional

	return $status
}

# -------------------------------------------------------

run_backup_rsync() {
	local date_time=$1

	setup_run_backup_priority && priority=high || priority=low

	if [[ -t 2 ]]
	   then local is_interactive=$true
	   else local is_interactive=$false
	fi

	local new_snapshot=$drive_dir/$date_time

	if [[ $is_interactive && $drive_name != Z ]] # Z = debug "drive"
	   then echo -n "rsync $dirs_to_backup $new_snapshot/; can CTRL-C ..."
		$IfRun sleep 5
		echo " too late."
	fi

	cd_ $drive_dir	# so can safely kill job with: fuser -k -M $drive_dir

	suspend_tracing
	eval "run_rsync $dirs_to_backup $new_snapshot" # might need globbing
	restore_tracing
}

# ----------------------

run_backup() {
	local drive_name=$1 drive_dir

	set_drive_name $drive_name
	set_drive_dir  $drive_name || return 1

	local date_time
	set_date_time

	if _is_time_to_run_backup $drive_dir
	   then local do_run_backup=$true
	   else local do_run_backup=$false
	fi

	if [[ $do_run_backup ]]
	   then local lock_opt=-w	# wait for lock, so don't skip backup
	   else local lock_opt=		# (we still want to manage prune)
	fi

	# the following is similar to the second half of copy_snapshot

	# grab backup lock before prune, so don't suspend prune if the sysadmin
	# suspended the backup and continued the prune
	lock $lock_opt backup || return 1

	_backup_management_of_prune pre-rsync

	if [[ $do_run_backup ]]
	   then	run_backup_rsync $date_time
		local status=$?
	   else local status=1
	fi

	_backup_management_of_prune post-rsync # last, for testing

	unlock backup

	return $status
}

##############################################################################-
##############################################################################-
# Functions and variables used to copy snapshots between backup drives.
##############################################################################-
##############################################################################-

assert_not_in_cron_jobs() {

	local name  drive_name
	for name
	    do	set_drive_name $name
		[[ $drive_name =~ ^$drive_name_regex$ ]] || continue
		local regex=drive_name_regex
		$IfRun abort "remove $drive_name from $regex= in $config_file"
	done
	return 0
}

# -----------------------------------------------------------------------------

bad_copy() {
	local msg=$*

	[[ $is_quiet || $is_update || $debug_opt ]] ||
	   abort "$msg; use -q to not abort"

	[[ ! $debug_opt ]] || echo "copy_snapshot: $msg"

	return 1
}

# ---------------------------------

backup_type=
declare -A drive_name2backup_type

set_backup_type() {
	local drive_name=$1	  # fastest if it's a drive_name not drive_dir

	backup_type=${drive_name2backup_type[$drive_name]-}
	[[ $backup_type ]] && return

	local $custom_config_vars
	if [[ $drive_name =~ ^$admin_drive_name_regex$ ]]
	   then [[ $is_drive_name_capitalized ]] && drive_name=${drive_name^}
		suspend_tracing
		customize_config_variables $drive_name
		restore_tracing
	   else set_drive_name $drive_name # calls customize_config_variables
	fi
	backup_type="$dirs_to_backup|$exclude_file|$extra_excludes"
	drive_name2backup_type[$drive_name]=$backup_type
}

# ---------------------------------

dst_backup_type=

matches_dst_backup_type() {
	[[ -o xtrace ]] && { set +x; local xtrace="set -x"; } || local xtrace=
	local drive_dir=$1

	local drive_name=${drive_dir#$drive_dir_prefix}
	set_backup_type $drive_name
	[[ $backup_type == $dst_backup_type ]]
	$xtrace
}

# ----------------------

dst_minimal_snapshot_regex=

is_src_snapshot_useful() {
	local src_snapshot=$1

	[[ -d $src_snapshot ]] || bad_copy "no snapshot '$1'" || return 1
	local  src_basename=${src_snapshot##*/}
	[[ $src_basename == $snapshot_pattern ||
	   $src_basename == $snapshot_pattern.links ]] ||
	   bad_copy "$src_snapshot is not a reliable snapshot" || return 1
	[[ $src_basename =~ $dst_minimal_snapshot_regex(|\..*) ]] ||
	   bad_copy "$src_snapshot doesn't fit $dst_name's backup_period=" ||
	   return 1

	matches_dst_backup_type ${src_snapshot%/*} && return 0

       bad_copy "$src_snapshot & $dst_drive_name backup characteristics differ"
}

# ---------------------------------

is_dst_snapshot_needed() {
	local dst_snapshot=$1

	set -- ${dst_snapshot%.*}*	# a version might exist
	[[ $# == 1    ]] ||
	   bad_copy "'$*' exist, (mv then) delete worst one" || return 1
	[[ $1 != *.rm ]] ||
	   bad_copy "destination is waiting to be pruned" || return 1
	[[ -e $1 ]] || return 0

	local ext=${1##*.} junk_dir=${dst_snapshot%/*}/.junk
	[[ ! -d $1 ]] &&
	   $IfRun mv $1 $junk_dir/ && { warn "junk in $junk_dir"; return 0; }
	! [[ ${1##*/} != *.* || $ext == links || $ext == partial ]] &&
	   $IfRun mv $1 $junk_dir/ && { warn "junk in $junk_dir"; return 0; }

	[[ ${1##*/} != *.* && ${dst_snapshot##*/} == *.* ]] && {
	[[ ! $is_quiet ]] && log "${dst_snapshot##*/} not needed"; return 1; }
	[[ $1 != $dst_snapshot ]] && return 0
	[[ $is_quiet || $action == update* ]] ||
	    log "$dst_snapshot already exists"; return 1
}

# ---------------------------------

dst_dir=
copy_snapshot_args=

copy_snapshot() {
	[[ $1 == -q ]] && { local is_quiet=$true ; shift; } || local is_quiet=
	[[ $1 == -u ]] && { local is_update=$true; shift; } || local is_update=
	[[ $1 != -* ]] || abort "$FUNCNAME: unknown option $1 (order matters)"
	(( $# >= 2  )) || abort "call as: $FUNCNAME src(s) dst_drive_name"
	local src_snapshot=${1%/} dst_drive_name=${!#}
	local src_snapshots=${*%$dst_drive_name}
	local drive_name=$drive_name drive_dir=$drive_dir # don't messup caller
	copy_snapshot_args=

	$Trace
	[[ $dst_minimal_snapshot_regex ]] || { # don't repeat dst setup
	set_drive_dir $dst_drive_name || abort "$dst_drive_name not mounted"
	dst_dir=$drive_dir
	local regex=${backup_period2minimal_snapshot_regex[$backup_period]}
	dst_minimal_snapshot_regex=$regex
	set_backup_type $dst_drive_name
	dst_backup_type=$backup_type	   ; }

	[[ $src_snapshot == /* && ! -L $src_snapshot ]] || {
	# the above criteria is alway satisfied by update, so we're 'copy' ...
	local absolute_path
	set_absolute_path $src_snapshot
	src_snapshot=$absolute_path
	src_snapshots=$absolute_path ; } # ... so only a single src

	local dst_snapshot=$dst_dir/${src_snapshot##*/}

	is_dst_snapshot_needed $dst_snapshot || return 1
	is_src_snapshot_useful $src_snapshot || return 1

	TraceV 2 src_snapshot dst_snapshot

	[[ ${debug_copy-} ]] &&
	    echo "copy $src_snapshot/\$dirs to $dst_dir/" && return 0

	[[ $is_update ]] &&
	    copy_snapshot_args="$src_snapshots $dst_snapshot" && return 0

	# use this if backup and/or prune needs to kill copy job
	# run_copy_job $src_snapshots $dst_snapshot; return

	copy_snapshot_rsync $src_snapshot $dst_snapshot
}

# -------------------------------------------------------

# The following is similar to the second half of run_backup_rsync;
# it's called by copy_snapshot and update_drive, to do the real work.
copy_snapshot_rsync() {
	local src_snapshot=$1 dst_snapshot=$2

	# grab prune lock, so backup job can suspend us
	lock -w prune $dst_snapshot || exit 1

	setup_copy_priority

	# lower nice value is higher priority
	[[   $cmd_to_set_copy_IO_priority < \
	   $cmd_to_set_higher_IO_priority ]] && priority=high || priority=low

	local cwd=$PWD
	cd_ $(dirname $dst_snapshot) # can kill job with: fuser -k -M $dst_dir
	run_rsync -c  $src_snapshot/. $dst_snapshot
	cd_ $cwd

	unlock -s prune
}

# -----------------------------------------------------------------------------

declare -A drive_name2do_suspend

load__drive_name2do_suspend() {

	local $custom_config_vars	# for customize_config_variables

	local drive
	for drive in $(list_drive_dirs -a)
	    do	local name=${drive#$drive_dir_prefix}
		suspend_tracing
		customize_config_variables $name
		restore_tracing
		if [[ $suspend_prune_when_backup ]]
		   then local value=1
		   else local value=0
		fi
		drive_name2do_suspend[$name]=$value
	done
}

# ---------------------------------

# the "fastest" snapshot is on drive that's: 1. not suspendable; else 2. not
# running a backup; else 3. not being pruned; else 4. hosting the smallest
# number of rsync commands.
fastest_snapshots() {

	local drive_name drive_dir	       # don't change caller's values

	local snapshot
	for snapshot
	    do	_set_drive_name $snapshot
		local do_suspend=${drive_name2do_suspend[$drive_name]}

		if ps_locks -R backup > /dev/null ||
		   ps_locks -R copy   > /dev/null
		   then doing_backup=1
		   else doing_backup=0
		fi

		if ps_locks -R prune > /dev/null
		   then local doing_prune=1
		   else local doing_prune=0
		fi

		drive_dir=$drive_dir_prefix$drive_name
		count_rsyncs_using_resource " $drive_dir/"
		local rsync_count=$?

		local ss=$snapshot
		echo "$do_suspend|$doing_backup|$doing_prune|$rsync_count|$ss"
	done | sort -t\| -n |		# numeric sort
	# cat; return			# uncomment to debug with action 'test'
	cut -d\| -f5
}

# --------------------------------------------

sorted_useful_srcs() {
	[[ $1 == -s* ]] && { src_names_regex=${1#-s}; shift; }
	[[ $1 != -*  ]] || abort "$FUNCNAME: unknown option $1"
	[[ $# == 1   ]] || abort "need to specify one drive name"

	suspend_tracing
	set_drive_name $1
	set_drive_dir  $drive_name
	restore_tracing

	if [[ ${src_names_regex-} ]]
	   then   if [[ $is_drive_name_upper_cased ]]
		   then src_names_regex=${src_names_regex^^}
		elif  [[ $is_drive_name_capitalized ]]
		   then src_names_regex=${src_names_regex^} # fails if regex
		fi
	fi

	set_backup_type $drive_name
	dst_backup_type=$backup_type
	local drive_dirs=$(
		set -- $(
		# -a so include drives excluded from backups
		set -- $(list_drive_dirs -a | fgrep -v -x $drive_dir |
				egrep "$drive_dir_prefix${src_names_regex-.}")
		for drive_dir
		    do	matches_dst_backup_type $drive_dir && echo $drive_dir
		done
		)
		echo $*
	)

	period=$backup_period
	min_snapshot_pattern=${backup_period2minimal_snapshot_pattern[$period]}

	set -f
	set -- $(echo root$drive_dir_prefix$drive_name_regex/snap |
		 tr / ' ')
	set +f
	let snapshot_key=$# drive_name_key=$#-1
	local sort_key_args="--key=$snapshot_key --key=$drive_name_key"

	TraceV 1 drive_dirs min_snapshot_pattern sort_key_args

	cd $drive_dir || exit 1	# so can kill job with: fuser -k -M $drive_dir

	$Trace

	for dir in $drive_dirs
	    do	suspend_tracing
		eval "echo $dir/$min_snapshot_pattern{,.links}" # useful ones
		      echo $dir/$max_snapshot_pattern # token to terminate loop
		restore_tracing
	done | tr ' ' '\n' |
	sort --field-separator=/ $sort_key_args
}

# -----------------------------------------------------------------------------

remove_empty_partial_snapshots() {
	local drive_dir=$1

	# 'sudo -n' because we're called by 'watch' and 'w'
	sudo -n rmdir $drive_dir/*.partial &> /dev/null # optional
}

# ---------------------------------

cleanup_after_updates() {

	set_sudo_lockpid

	local drive_dir drive_name
	for drive_dir in $(list_drive_dirs -a)
	    do	_set_drive_name $drive_dir
		set_lock_path copy	# update could be running
		$sudo_lockpid    $lock_path &> /dev/null || continue
		$IfRun remove_empty_partial_snapshots $drive_dir
		$sudo_lockpid -r $lock_path
	done
}

# --------------------------------------------

update_drive() {
	set_drive_name ${!#}		# sorted_useful_srcs handles options

	# need to grab the copy lock in debug mode, pruning runs mv & rmdir
	IfRun= lock copy > /dev/null || exit 1 # can run for days

	set_drive_dir $drive_name
	remove_empty_partial_snapshots $drive_dir

	local srcs_dst_file=$tmp_dir/$_our_name-update-$drive_name.args
	local date_time prev_date_time=
	local src_snapshot src_snapshots=
	sorted_useful_srcs "$@" |	# this checks/sets drive_* globals
	while read src_snapshot
	    do	# oddness: we get multiple src snapshots with the same date
		date_time=$(basename $src_snapshot)
		date_time=${date_time%%.*}
		if [[  $prev_date_time &&
		       $prev_date_time != $date_time ]]
		   then prev_date_time=$date_time # new date, process prev ones
		   else [[ $prev_date_time ]] ||
			prev_date_time=$date_time
			src_snapshots+=" $src_snapshot"
			continue
		fi

		copy_snapshot -u $src_snapshots $drive_name
		 src_snapshots=$src_snapshot # prepare to process new date
		set -- $copy_snapshot_args
		[[ $# != 0 ]] || continue

		local    dst_snapshot=${!#}
		[[ ! -d $dst_snapshot.links ]] &&
		sudo mkdir $verbose_opt -p $dst_snapshot.partial >&2 # to prune
		echo "$@"
	done > $srcs_dst_file
	[[  -s $srcs_dst_file ]] || { rm $srcs_dst_file; return 1; }

	prune_drive -u $drive_name	# just prunes empty .partial dirs

	load__drive_name2do_suspend
	local args dst_snapshot=
	while read args
	    do	set -- $args
		local   dst_snapshot=${!#}
		[[ -d  $dst_snapshot ]] && continue # undeleted?
		set -- $dst_snapshot*
		[[ -d  $1 ]] || continue # was it pruned away?
		set -- $(fastest_snapshots ${args%$dst_snapshot}) # pass srcs
		[[ $# != 0 ]] && $IfRun copy_snapshot_rsync $1 $dst_snapshot
	done < $srcs_dst_file
	rm     $srcs_dst_file

	remove_empty_partial_snapshots $drive_dir

	IfRun= unlock copy
}

##############################################################################-
##############################################################################-
# Run multiple jobs, each in a separate session (unique PGID, stored in lock).
##############################################################################-
##############################################################################-

# Run a bunch of jobs in parallel, each in its own session (so lock files
# will hold PGID (process-group ID), making 'kill' and 'ps' easy).
# We run backups simultaneously, so they all share the cached source files;
# we run prunes  simultaneously, since a prune's I/O stays on its own drive.
run_jobs_in_parallel() {
	local type=$1; shift
	local opts= are_recursing=$false
	while [[ $1 == -[^r]* ]] ; do opts+=" $1"; shift; done
	[[ $1 == -r  ]] && { are_recursing=$true; shift; }
	if [[ $debug_opt && ${HOSTNAME-} == eleanor ]]
	   then local excluded_regex='\bG$' # G is too slow
	   else local excluded_regex=NoThInG
	fi
	[[ $1 == all ]] &&
	set -- $(list_drive_dirs | egrep -v "$excluded_regex")
	[[ ! $debug_opt ]] &&
	set -- $(echo $* | tr ' ' '\n' | tac) # ps shows new proc 1st

	case $type in
	   ( backup ) function=run_backup   exe=$run_backup_exe  ;;
	   ( prune  ) function=prune_drive  exe=$prune_drive_exe ;;
	   ( update ) function=update_drive exe=$update_drive_exe ;;
	   (   *    ) abort "'$type' is not supported" ;;
	esac

	if [[ $are_recursing ]]
	   then $Trace
		$function $opts $1
		exit $?
	fi

	[[ ! $debug_opt && $* != [Zz] && -t 1 ]] && echo -e "
	NOTE: your $action command will run as a separate, disconnected job;
	      and it might wait for a lock before it can start.  See it with:

		$_our_name watch
"

	$Trace
	for name
	    do	_set_drive_name $name && name=$drive_name # cleanup for 'ps'
		if [[ ! $debug_opt && $drive_name != Z ]]
		   then trap '' HUP
			# Can't "$function name &", processes share lock files.
			# Want new process-group so can ps/kill independently.
			setsid \
			$exe $opts -r $name &
		   else $exe $opts -r $name # run in foreground, for testing
			echo
		fi
	done
}

# -----------------------------------------------------------------------------

# We can be killed by either a prune job that desparately needs our source
# drive, or a backup job to our destination drive, so we need to restart;
# and since we can be killed to steal either our source or destination
# lock, we need to manage all locks.
run_copy_job() {

	if [[ $1 != -r ]]		# not Recursing, so need new job?
	   then $Trace
		trap '' HUP
		# backup job or (desparate) prune job can kill us to steal lock
		until setsid $copy_snapshot_exe -r "$@"
		   do	$IfRun sleep $lock_share_secs
		done
		return 0
	fi

	shift				# toss -r; we're now a new job
	[[ $1 != -* ]] || abort "$FUNCNAME: unknown option $1"
	local dst_snapshot=${!#}
	local src_snapshots=${*%$dst_snapshot}

	$Trace
	until   lock -w prune $src_snapshots &&
		lock   backup $dst_snapshot 2> /dev/null
	   do	unlock -s prune	# didn't get backup lock; drop/share prune lock
		set +x
	done
	local src_snapshot=${lock_type2locked_resource[prune]}
	$Trace
	copy_snapshot_rsync $src_snapshot $dst_snapshot
	unlock backup
	unlock -s prune
	return 0		# else infinite loop, see above
}

##############################################################################-
##############################################################################-
# 'watch' action.
##############################################################################-
##############################################################################-

set_stats_format() {
	[[ -o xtrace ]] && { set +x; local xtrace="set -x"; } || local xtrace=
	local drive_dirs=$*

	declare -i format_width
	local format=
	local drive_dir drive_name
	for drive_dir in $drive_dirs
	    do	_set_drive_name $drive_dir
		format_width=${#drive_name}+5
		format+=" %-${format_width}s"
	done
	stats_format=${format# }
	TraceV 1 stats_format
	$xtrace
}

# ---------------------------------

rsync_hour_avgs=
rsync_hour_maxs=

set__rsync_hour_avgs__rsync_hour_maxs() {

	set_stats_format $all_drive_dirs
	local hour_avgs= hour_maxs=
	local dir drive_name format=
	for dir in $all_drive_dirs
	    do	_set_drive_name $dir
		local name=$drive_name
		local  dir=$log_dir/$name/$rsync_time_subdir
		set -- $dir/$snapshot_pattern.txt
		[[ -f $1 ]] || shift
		if [[ $# != 0 ]]
		   then local sum=$(cat $* | tr '\n' '+')
			declare -i total=${sum%+}
			hour_avg=$(echo $total $# |
				   awk '{ printf "%.1f", $1/($2*60) }')
			hour_max=$(sort -n -r $* |
				   awk '{ printf "%.1f", $1/60; exit }')
		   else hour_avg= hour_max=
		fi
		hour_avgs+=" $name=$hour_avg"
		hour_maxs+=" $name=$hour_max"

	done

	printf -v rsync_hour_avgs "$stats_format" $hour_avgs
	printf -v rsync_hour_maxs "$stats_format" $hour_maxs
}

# -----------------------------------------------------------------------------

_set_age() {
	local snapshot=$1

	set_seconds $snapshot
	declare -i snap_secs=$seconds
	declare -i  now_secs=$(date '+%s')
	age=$(( ($now_secs - $snap_secs)/(24*60*60) ))
}

# ------------------

oldest_age=
newest_age=

_setup_ages() {

	_set_age $1    ; oldest_age=$age
	_set_age ${!#} ; newest_age=$age
}

# ---------------------------------

stats_number=
stats_oldest_age=
stats_newest_age=

_recalculate_stats_vars() {

	local cwd=$PWD nums= oldies= newies=
	for dir in $all_drive_dirs
	    do	set_drive_name $dir
		local name=$drive_name
		cd $dir || abort "cd $dir"
		ending=${type2date_suffix_pattern[$ignored_date_ending_type]}
		ending_RE=${ending//\?/.}
		suspend_tracing
		set -- $snapshot_pattern$suffix
		restore_tracing
		[[ -d $1 ]] || shift
		[[ $# != 0 ]] &&
		set -- $(echo $* | tr ' ' '\n' |
			   sed "s/$ending_RE$//" | uniq)
		restore_tracing

		nums+=" $name=$#"

		[[ $dates ]] || continue
		if [[ $# != 0 ]]
		   then _setup_ages $*
			local old=$oldest_age	new=$newest_age
		   else local old=		new=
		fi
		oldies+=" $name=$old"
		newies+=" $name=$new"
	done
	cd $cwd || abort "cd $cwd"

	printf -v stats_number     "$stats_format" $nums    ; [[ $dates ]] && {
	printf -v stats_oldest_age "$stats_format" $oldies
	printf -v stats_newest_age "$stats_format" $newies		    ; }
}

# ----------------------

readonly watch_cache_dir=$log_dir/stats/watch
readonly cached_drive_dirs_file=$watch_cache_dir/drive-dirs.txt

setup_snapshot_stats() {
	local suffix=$1 ignored_date_ending_type=${2:-NONE} # NONE used in prune arrays

	[[ $suffix ]] && local suffix_name=${suffix/\*/STAR} || local suffix_name=NONE
	suffix_name=${suffix_name#.}
	local cache_name="suffix=$suffix_name,ignored=$ignored_date_ending_type.txt"
	local  lock_name=stats-$suffix_name,$ignored_date_ending_type.pid

	[[ $suffix == .rm ]] && suffix=*$suffix
	[[ $ignored_date_ending_type == NONE ]] &&
	   local dates=$true || local dates=$false

	local     number_cache_file=$watch_cache_dir/number/$cache_name
	local oldest_age_cache_file=$watch_cache_dir/oldest-age/$cache_name
	local newest_age_cache_file=$watch_cache_dir/newest-age/$cache_name
	local drive_dirs=$all_drive_dirs
	local dir drive_name
	local found_modified_drive=$false
	for dir in $drive_dirs
	    do	[[ $number_cache_file -nt $dir/. ]] && continue
		found_modified_drive=$true
		break
	done
	[[ -s $cached_drive_dirs_file ]] &&
	[[ $drive_dirs == "$(< $cached_drive_dirs_file)" ]] &&
	if [[ ! $found_modified_drive ]]
	   then stats_number=$(< $number_cache_file)
		[[ $dates ]] && {
		stats_oldest_age=$(< $oldest_age_cache_file)
		stats_newest_age=$(< $newest_age_cache_file)
		}
		# echo -n C:		# uncomment to ensure cache is working
		return
	fi

	_recalculate_stats_vars

	# it takes ~0.05 secs/drive to calculate stats, called 9 times: cache
	[[ -w $log_dir ]] || return # might not have write access to the cache
	local lockpid_args="--dir=$lock_dir $lock_name"
	lockpid $lockpid_args > /dev/null || return

	mkdir -p ${number_cache_file%/*} ${oldest_age_cache_file%/*} \
					 ${newest_age_cache_file%/*}
	echo "$drive_dirs" > $cached_drive_dirs_file
	echo "$stats_number"	 >     $number_cache_file   ; [[ $dates ]] && {
	echo "$stats_oldest_age" > $oldest_age_cache_file
	echo "$stats_newest_age" > $newest_age_cache_file		    ; }

	lockpid --release $lockpid_args
}

# -----------------------------------------------------------------------------

run_df() {
	local drive_dirs=${*:-$(list_drive_dirs -a)}

	echo
	local df_fields=source,fstype,size,avail,used,pcent,iused,ipcent,target
	df --block-size=G --output=$df_fields $drive_dirs
}

# --------------------------------------------

run_lsblk() {
	local drive_dirs=${*:-$(list_drive_dirs -a)}

	type -t lsblk > /dev/null || return 1

	local dir devices=
	for dir in $drive_dirs
	    do	set_FS_device___from_path $dir &&
		devices+=" $FS_device"
	done

	echo
	# fields that don't work: rm,model
	lsblk_fields=name,fstype,type,rota,size,state,sched,opt-io,mountpoint
	lsblk --output=$lsblk_fields --sort mountpoint  $devices 2>/dev/null ||
	lsblk --output=$lsblk_fields			$devices
}

# -----------------------------------------------------------------------------

trim() {

	# when prune excludes, prune & cron-job can both have a multi-arg 'rm'
	sed -e 's@\( rm [^0-9]*[0-9][^ ]* \).*@\1...@'	\
	    -e "s@ --pid=[0-9]* --dir=$lock_dir @ @"	\
	    -e "s@ --pid=[0-9]* @ @"	\
	    -e 's@/bin/bash /@/@'	\
	    -e 's@ bash /@ /@'		\
	    -e 's@ /usr/local/bin/@ @'	\
	    -e "s@ $HOME/@ ~/@g"
}

# --------------------------------------------

trim_backup() {

	trim |
	sed -e 's@run-backup -r @run-backup @g' \
	    -e 's@ --.* @ $opts -R $dirs @' \
	    -e "s@$drive_dir_prefix@@g"	# remove prefix last
}

# --------------------------------------------

trim_prune() {

	trim |
	sed -e 's@prune-drive -r @prune-drive @g'
}

# --------------------------------------------

trim_copy_update() {

	set -- $rsync_backup_opts	# standardize whitespace

	local cpss="$_our_name c"
	trim |
	# makes *.links copy wrap: -e "s@ $* /@ \$opts /@" \
	# makes *.links copy wrap: -e 's@ --.* --link-dest=[^ ]* /@ $opts /@' \
	sed -e '/update-drive/s@ -r @ @g' \
	    -e '/update-drive/s@ -s@ -s @' \
	    -e 's@ --.* --link-dest=[^ ]* /@ /@' \
	    -e "/[0-9]   $_our_name/d" \
	    -e "s@ $* /@ /@" \
	    -e "/$cpss/s@\($_our_name[^0-9]*[^ ]*\)..*\(.\) *\$@\1 ... \2@" \
	    -e 's@/[^/]*/\. /@/$snap/. /@' \
	    -e "s@$drive_dir_prefix@@g"	# remove prefix last
}

# ------------------------------------------------------------------

watch() {
	local watch_opt= ps_opt= cron_opt= names=
	[[ ${1-} == -w ]] && { watch_opt=-w; shift; } # internal option
	[[ ${1-} == -f ]] && {    ps_opt=-f; shift; }
	[[ ${1-} == -C ]] && {  cron_opt=-C; shift; }
	[[ ${1-} == -f ]] && {    ps_opt=-f; shift; }
	[[ ${1-} == -N ]] && {     names=$2; shift 2; }
	[[ $is_cron ]] && cron_opt=-C

	local all_opts="$ps_opt $cron_opt"
	if [[ $names ]]
	   then [[ $is_drive_name_upper_cased ]] && names=${names^^}
		all_opts+=" -N $names"
	fi
	[[ ${SSH_TTY-}  ]] && n=0.5 || n=0.1
	[[ $watch_opt   ]] || cleanup_after_updates
	[[ $action == w ]] ||
	   exec watch -d -p ${*:- -n $n} $our_path $our_opts w -w $all_opts

	set -- $(list_drive_dirs -a)
	local all_drive_dirs=$*
	local drive_dirs= show_all=$false
	if [[ $names ]]
	   then local name_list=
		for name in ${names//,/ }
		    do	_set_drive_name $name
			drive_dirs+=" $drive_dir_prefix$drive_name"
			name_list=$name_list,$drive_name
		done
		names=${name_list#,}
		# show_all=$true   cron_opt=-C
	   else show_all=$false
		drive_dirs=$all_drive_dirs
	fi
	[[ $names ]] && names_pat="{$names}" &&
	    names_msg=" for $names " || names_msg=
	[[ $watch_opt ]] || ps_opt=-f cron_opt=-C show_all=$true

	TraceV 1 names drive_dirs names_pat ps_opt cron_opt show_all

	# ------------------------------------------------------------------

	set -- $(stty -a | head -n1)
	declare -i rows=${5%;} cols=${7%;}
	export COLUMNS=$cols		# for 'ps'

	#
	# figure out how many columns are needed
	#

	# since the contents of $() are run in subshell, have to echo results
	set -- $(
	declare -i max_device_len=0 max_mount_len=0
	df --block-size=G $drive_dirs |
	while read device size used avail used mount junk
	    do	declare -i device_len=${#device} mount_len=${#mount}
		is_new_max=$false
		[[ $mount == /* ]] &&	# skip header
		(( $max_mount_len  < $mount_len  )) &&
		    max_mount_len=$mount_len	is_new_max=$true
		(( $max_device_len < $device_len )) &&		  # also header
		    max_device_len=$device_len	is_new_max=$true
		[[ $is_new_max ]] && echo $max_device_len $max_mount_len
	done | tail -n1
	)
	declare -i max_device_len=$1 max_mount_len=$2

	# widest -f -C line is child rsync: 79 cols + wchan + drive mountpoint
	widest_wchan_value=call_rwsem_down_read_failed # linux-3.2
	widest_wchan_value=balance_dirty_pages.isra.17 # linux-3.2
	widest_wchan_value=balance_dirty_pages.isra.24 # linux-4.x
	declare -i max_ps_wchan_width=${#widest_wchan_value}+1
	declare -i ps_wchan_width=10	 # min useful
	declare -i ps_overhead=79

	if (( $cols >= $ps_overhead + $ps_wchan_width + $max_mount_len ))
	   then ps_wchan_width=cols-ps_overhead-max_mount_len  ps_opt=-f
		(( ps_wchan_width > max_ps_wchan_width )) &&
		   ps_wchan_width=max_ps_wchan_width
	fi

	ps_() { ps $ps_opt    "$@" | trim_ps_cols; }
	psc() { ps $ps_opt -C "$@" | trim_ps_cols; }
	if [[ $ps_opt ]]
	   then # don't need uid, always root (if have a TTY, it's a sysadmin)
		trim_ps_cols() { cut -c "10-21,25-37,40-43,46-"; }
		hdr="UID        PID  PPID  C STIME TTY      STAT   TIME CMD"
		#    123456789012345678901234567890123456789012345678901234567
		#             1         2         3         4         5
		prune_sort_opts="-k7r,8 -k9"	rsync_sort_opts="-k11"
	   else trim_ps_cols() { cut -c 1-13,16-20,22-; }
		hdr="  PID TTY      STAT   TIME COMMAND"
		#    123456789012345678901234567890123456789012345678901234567
		#             1         2         3         4         5
		prune_sort_opts="-k5r,6 -k7"	rsync_sort_opts="-k8"
	fi

	# ------------------------------------------------------------------

	customize_and_validate_configuration_variables

	#
	# figure out how many rows are needed
	#

	eval \
	"set -- \$(cat $lock_dir/backup-${names_pat:-*}.pid 2> /dev/null)"
	[[ $# == 0 ]] && rsync_cmds= ||
	set -- $(echo " $*" | sed 's/ / -/g') && # want all processes in group
	rsync_cmds=$(COLUMNS=999 ps_ -H ww  $* |
			grep "[0-9]   rsync" | sed 's/   rsync/ rsync/')
	declare -i num_rsyncs=$(echo "$rsync_cmds" | wc -l)
	declare -i num_drives=$(set -- $drive_dirs; echo $#)

	eval "set -- $lock_dir/prune-${names_pat:-*}.pid"
	[[ -e $1 ]] || shift
	[[ $# != 0 && ! ( $debug_opt || $show_all ) ]] &&
	set -- $(echo $* | tr ' ' '\n' | fgrep -v /prune-Z.); [[ $# != 0 ]] &&
	set -- $(cat  $* 2>/dev/null)
	[[ $# == 0 ]] && prune_cmds= || {
	set -- $(echo " $*" | sed 's/ / -/g') # want all processes in group
	prune_cmds=$(COLUMNS=999 ps_ w -H h $* 2>/dev/null  |
			fgrep -e ' rm ' -e ' prune-' -e ' pd ' -e ' lockpid ' |
			trim_prune)
	}

	#
	# both update-drive and copy-snapshot use the copy lock
	eval \
	"set -- \$(cat $lock_dir/copy-${names_pat:-*}.pid 2>/dev/null)"
	set_locks prune $* && copy_lock_msg="; PRUNE LOCKS: ${locks//prune-/}"
	[[ $# == 0 ]] && cp_rsync_cmds= ||
	set -- $(echo " $*" | sed 's/ / -/g') && # want all processes in group
	cp_rsync_cmds=$(COLUMNS=999 ps_ -H ww $* |
			 egrep -e "[0-9] .*$_our_name.* [cu]" \
			       -e " [l]ockpid " \
			       -e "[0-9]     rsync" |
			   sed -e 's/   rsync/ rsync/')
			#      -e 's/   lockp/ lockp/')	# -> harder to notice
	#
	rsync_or_rm_cmd_PGIDs_file=$tmp_1
	ps -u root -O pgid,command | egrep '\b(rsync|rm) ' |
	   awk '{print $2}' > $rsync_or_rm_cmd_PGIDs_file
	cron_job_regex=' -C run-backups? ' # put into configure.sh ??
	set -- $(COLUMNS=999 ps -u root -O pgid,command |
			egrep "$cron_job_regex" |
			fgrep -w -f $rsync_or_rm_cmd_PGIDs_file |
			awk '$0 !~ /setsid / {print $2}' | sort -u -n)
	cron_PGIDs=$*
	rm $rsync_or_rm_cmd_PGIDs_file

	# only show un-asked cron jobs if no rsync details to show
	[[ ($cron_opt || ! $rsync_cmds$cp_rsync_cmds) && $# != 0 ]] && {
	set -- $(process_group_PIDs $cron_PGIDs)
	[[ $ps_opt ]] && wchan=,wchan:$ps_wchan_width || wchan=
	[[ $wchan ]] && sudo -n ps &> /dev/null && sudo=sudo || sudo= wchan=
	#  option f for "forest"
	cron_cmds=$($sudo ps www f -o pid,stat$wchan,bsdtime,command $*)
	} || cron_cmds=

	# prune-drive (PD) includes parent of  'rm'   process (also in -C)
	#  copy-snap  (CS) includes parent of 'rsync' process (also in -C)
	declare -i PD=$(echo    "$prune_cmds" | fgrep -c 'prune-drive')
	(( PD > 0 )) && let PD=PD*2+4	# add in 'rm' plus section-overhead
	declare -i CS=$(echo "$cp_rsync_cmds" | egrep -c '(update|copy)-')
	(( CS > 0 )) && let CS=CS*2+4	# add in 'rsync' plus section-overhead
	declare -i RB=$(echo    "$rsync_cmds" | fgrep -c rsync)
	(( RB > 0 )) && let RB+=3+4+3	# default + (details section + 1 rsync)
	(( RB > 0 )) && let RB+=2	# hack, to ensure we see one full rsync
	TraceV 1 PD CS RB && let rows-=3
	# min overhead: 1 watch line, 1 blank line, 2 hours to create,
	#   2 good snapshots, 4 lines of empty backup section.
	# the copy (CS) section is only printed if there's some activity.
	declare -i min_rows=$((  6 + 4 + PD + CS + RB )); [[ $cron_opt ]] &&
		   min_rows+=$(( 4 + 5*num_rsyncs + PD ))
	declare -i min_df_rows=$(( min_rows + 2 + num_drives ))
	(( $Trace_level > 0 )) && let rows-=3 # for the next TraceV
	TraceV 1 rows min_rows min_df_rows


	# ------------------------------------------------------------------
	# now we're ready to start showing stuff to the user
	# ------------------------------------------------------------------

	declare -i min_for_rare=$(( min_df_rows + 6 + 7 + 6 ))
	[[ ! -s /etc/sudoers.d/$_our_name &&
	   ( $rows -gt $min_for_rare || $show_all ) ]] && {
		header -E "to not fill the log with frequent 'sudo ps'"
		echo
		option_1="install etc/sudoers.d/$our_name"
		option_2="put its contents into /etc/sudoers"
		echo -e "$option_1, or $option_2"

		header "statistics"
		echo
		let rows-=6		# only adjust for optional sections
	}

	# ------------------------------------------------------------------

	set__rsync_hour_avgs__rsync_hour_maxs
	echo "Average hours to create rsync snapshot:  $rsync_hour_avgs"
	echo "Maximum hours to create rsync snapshot:  $rsync_hour_maxs"
	setup_snapshot_stats ''
	echo "  Age of oldest good snapshot, in days:  $stats_oldest_age"
	echo "  Age of newest good snapshot, in days:  $stats_newest_age"

	# --------------------------------------------

	declare -i rows_used=7
	(( $rows >= ($min_rows + $rows_used) )) || [[ $show_all ]] && {
	echo
	setup_snapshot_stats .rm
	echo " Number pruned snapshots awaiting 'rm':  $stats_number"
	echo "  Age of newest pending prune, in days:  $stats_newest_age"
	setup_snapshot_stats .links
	echo " Number .links (failed 'ln') snapshots:  $stats_number"
	echo "     Days since 'Too many links' error:  $stats_newest_age"
	setup_snapshot_stats .partial
	echo "Number .partial snapshots, updates+err:  $stats_number"
	echo "Days from most recent snapshot.partial:  $stats_newest_age"
	let rows-=$rows_used
	}

	# --------------------------------------------

	declare -i rows_used=6
	(( $rows >= ($min_df_rows + $rows_used) )) || [[ $show_all ]] && {
	echo
	setup_snapshot_stats ''
	echo "     Total number successful snapshots:  $stats_number"
	setup_snapshot_stats '' hour
	echo "  Total number  days  w/good snapshots:  $stats_number"
	setup_snapshot_stats '' day
	echo "  Total number months w/good snapshots:  $stats_number"
	setup_snapshot_stats '' month
	echo "  Total number years  w/good snapshots:  $stats_number"
	setup_snapshot_stats '*'
	echo "  Total snapshots (good, partial, .rm):  $stats_number"
	let rows-=$rows_used
	}

	# ------------------------------------------------------------------

	if [[ $show_all ]]
	   then filesystem_geometry $drive_dirs
	   else	(( $rows >= $min_df_rows )) &&
		run_df $drive_dirs &&
		let rows-=$num_drives+2

		# --------------------------------------------

		(( $rows >= $min_df_rows )) && [[ ! $cp_rsync_cmds ]] &&
		run_lsblk $drive_dirs &&
		let rows-=$num_drives+2
	fi

	# ------------------------------------------------------------------

	psc rm w | fgrep ' pts/' | sort $prune_sort_opts > $tmp_1
	declare -i admin_PD=$(wc -l < $tmp_1)+3 # 3 is the overhead
	declare -i ad_hoc_min_rows=$min_rows+$admin_PD
	if [[ -s $tmp_1 && ( $rows -ge $ad_hoc_min_rows || $show_all ) ]]
	   then header "ad-hoc pruning by sysadmin (i.e. TTY != '?')"
		echo
		echo "$hdr" | trim_ps_cols
		trim_prune < $tmp_1
		let rows-=$admin_PD
	fi
	rm $tmp_1

	# ------------------------------------------------------------------

	# if prune in cron section, don't usually also show it in prune section
	echo "$cron_cmds" | sed -n 's/.*prune-drive/prune-drive/p' > $tmp_1
	[[ ! $show_all ]] &&
	   prune_cmds=$(echo "$prune_cmds" | fgrep -v -f $tmp_1) &&
	   let rows+=$(wc -l < $tmp_1)
	rm $tmp_1

	let snapback_cmd_count="($PD-4)/2" # 4 is section overhead
	(( $rows < ( $min_rows + $snapback_cmd_count ) )) &&
	   fgrep_opt="-e prune-drive" && # just want 'rm' commands
		let rows+=$snapback_cmd_count || fgrep_opt=
	prune_cmds=$(echo "$prune_cmds" |fgrep -v -w -e xargs -e tr $fgrep_opt)

	[[ $prune_cmds || $show_all ]] && {
	header "cron's run-prune"
	echo
	}

	if [[ $prune_cmds ]]
	   then echo "$hdr" | trim_ps_cols
		echo "$prune_cmds"
	elif [[ $show_all ]]
	   then echo -e "No pruning is being done$names_msg."
	fi

	# ------------------------------------------------------------------

	# copy-snapshots uses prune lock
	[[ $cp_rsync_cmds && ( $show_all || ! $cron_opt ) ]] && {
	header "copy (& update)${copy_lock_msg-}"
	echo
	echo "$hdr" | trim_ps_cols
	echo "$cp_rsync_cmds" | trim_copy_update # | sort $prune_sort_opts
	}

	# ------------------------------------------------------------------

	# for some reason, appending newlines does nothing?!
	rsync_abbrev_msg="
	  default opts=\"$rsync_backup_opts\" (\$rsync_backup_opts)
	  default dirs=\"$dirs_to_backup\" (\$dirs_to_backup)
	"
	rsync_abbrev_msg=$(echo "$rsync_abbrev_msg" | sed 's/^\t//')

	header "cron's run-backups' lead rsync processes (abbreviated)"
	[[ $rsync_cmds ]] && {
	echo "$rsync_abbrev_msg"; echo
	echo "$hdr" | trim_ps_cols
	echo "$rsync_cmds" | trim_backup | sort $rsync_sort_opts
	} || echo -e "\nNo backups are running$names_msg."

	# ------------------------------------------------------------------

	# show process tree of master cron job(s)
	[[ $cron_cmds ]] && {
	stime=$(set -- $(ps h -o stime $cron_PGIDs | sort -u); echo $*)
	regex=${cron_job_regex%%s*}
	header "$stime: '$regex' cron job(s), PGID='$cron_PGIDs'"; echo
	(( $rows < $min_rows )) && echo "${rsync_abbrev_msg#?}" && echo
	echo "$cron_cmds" | trim_backup
	}

	# ------------------------------------------------------------------

	[[ $rsync_cmds ]] && {
	header "cron's run-backups' lead rsync processes (full details)"
	echo
	echo "$hdr" | trim_ps_cols
	echo "$rsync_cmds" | sed "s@ $HOME/@ ~/@g"
	}

	# ------------------------------------------------------------------

	[[ $cp_rsync_cmds ]] && {
	header "copy's & update's rsync processes (full details)"
	echo
	echo "$hdr" | trim_ps_cols
	echo "$cp_rsync_cmds" | sed -n "s@ $HOME/@ ~/@g; /\brsync /p"
	}
}

##############################################################################-
##############################################################################-
# Functions for creating/altering filesystems.
##############################################################################-
##############################################################################-

# for each name (can be 'all'), kill any backups/pruning/etc & unmount drive
unmount_drives() {
	[[ $1 == -q  ]] && { shift; is_OK_if_drive_dir_unmounted=$true; }
	[[ $1 != -*  ]] || abort "$FUNCNAME: unknown option $1"
	[[ $* == all ]] && set -- $(list_drive_dirs)

	$Trace
	# do this early, since takes a while for processes to die
	$IfRun kill_all_jobs "$@"

	[[ $debug_opt ]] && local output=/dev/stdout || local output=/dev/null
	local name drive_name drive_dir status=0
	for name
	    do	set_drive_name $name
		set_drive_dir $drive_name
		is_drive_mounted $drive_dir || continue
		sudo umount -h &> /dev/null || warn "need sudo privs" || break
		umount_cmd="$IfRun sudo umount -v $drive_dir"
		for (( i = 1; i <= 99; i++ )) # wait for kill to finish
		    do	$umount_cmd && break
			$IfRun sleep 0.1
		done &> $output
		is_drive_mounted $drive_dir || continue
		$umount_cmd || status=$? # this time, show the error message
	done
	return $status
}

# add-extN-journal drive_name [FS_device [VG_name]]: fast external journal
add_extN_journal() {
	[[ ${1-} == -M ]] && { local  do_mount=  ; shift; } || local do_mount=t
	[[ ${1-} == -f ]] && { local force_opt=$1; shift; } || local force_opt=
	[[ $# == [1-4] ]] ||
	   abort "{-l FS_label | drive_name} [device [VG-name]]"
	if [[ $1 == -l ]]
	   then shift;  local FS_label=$1
	   else local name=$1 FS_label=
	fi
	[[ $1 != -* ]] || abort "$FUNCNAME: unknown option $1 (order matters)"
	local FS_device=${2-} VG_name=${3-}

	[[ $UID == 0 ]] || $IfRun abort "run with sudo"

	[[ ! $FS_label ]] && {
	is_OK_if_drive_dir_unmounted=$true
	set_drive_name $1
	set_drive_dir $drive_name
	mount_dir=$drive_dir
	set_FS_label___from_mount_dir $mount_dir ; }
							[[ $FS_device ]] ||
	set_FS_device___from_FS_label $FS_label
	[[ ${mount_dir-} ]] ||
	   set_mount_dir___from_FS_label $FS_label ||
	   set_mount_dir___from_FS_device $FS_device
	TraceV 1 force_opt FS_label FS_device VG_name mount_dir

	sudo tune2fs -l $FS_device | grep -q '^Journal ' &&	  {
	warn "removing internal journal can take many minutes"
	$IfRun tune2fs $force_opt -O ^has_journal $FS_device	; }

	set_FS_external_log $force_opt $FS_label $VG_name ||
	warn "invalid set_FS_external_log, or $config_file says log unwanted"||
	   { $IfRun tune2fs -j $FS_device; return $?; }
	label=$(basename $FS_external_log)

	$Trace

	RunCmd mke2fs -v -b 4096 -O journal_dev -L $label $FS_external_log

	suspend_tracing
	RunCmd -d unmount_drives -q ${mount_dir:-$FS_device}
	restore_tracing
	mount | fgrep -w $FS_device && $IfRun abort "must: umount $FS_device"

	RunCmd tune2fs -J device=LABEL=$label $FS_device
	$IfRun tune2fs -l $FS_device | grep -i "journal [id]"
	local status=${PIPESTATUS[0]}

	[[ $do_mount ]] || return $status

	mount_options=$common_mount_options,$extN_mount_options
	RunCmd mount -v -t ext4 -o ${mount_options%,} $FS_device $mount_dir
}

# -----------------------------------------------------------------------------

total_dir_MB=
avg_dir_KB=

set__total_dir_MB__avg_dir_KB() {
	local file=${1%.bz2}.bz2

	isize=$(echo $file | sed -r 's/.*-inode=([0-9]+)-.*/\1/')
	set -- $( bzcat $file |
		  awk --assign isize=$isize --field-separator K \
			'{ space += ($1*1024) + isize; count += 1 }
			 END { printf "%.1f %.2f\n",
					space/(1024*1024),
					space/(1024*count)}' )
	total_dir_MB=$1 avg_dir_KB=$2
}

# --------------------------------------------

# dir-sizes [-f | name]: generates stats for 'mkfs -b'; -f -> choose old file
dir_sizes() {
	set__drive_log_dir__file_for_logging__admin_group__is_regression_test
	readonly sizes_dir=$drive_log_dir/dir-sizes
	mkdir -p -m g+w,o-w $sizes_dir || abort "need to use sudo"
	cd_ $sizes_dir

	suffix=ls-s-d

	if [[ $# == 0 ]]
	   then echo -e "\nThe actual drive-space consumed by a directory is"
		echo -e "the size of: its directory block(s) plus its inode:\n"
		set -- *.$suffix.bz2
		[[ -f $1 ]] ||
		   abort "no saved data files, you need to run: $our_name name"
		for file
		    do	set__total_dir_MB__avg_dir_KB $file || continue
			space="all dirs use $total_dir_MB MB/snapshot"
			  avg="$avg_dir_KB KB/dir"
			printf "%46s: %s\n" "$space ($avg)" ${file%%.*}
		done | sort -k4n	# sort by total size
		echo
		exit
	fi

	if [[ $1 == -f ]]
	   then set -- $(/bin/ls *.$suffix.bz2 | sed 's/\.bz2//')
		[[ -f $1.bz2 ]] || abort "don't have any old data files"
		PS3="specify file number: "
		select file
		   do	[[ $file ]] && break
		done || exit 1
	   else file=  name=${1-}
		[[ $# == 1 && $name && $name != -* ]] ||
		   abort_with_action_Usage
		set_drive_name $1
	fi
	[[ ${1-} != -* ]] || abort "$FUNCNAME: unknown option $1"

	[[ $file ]] || {

	drive_dir=$drive_dir_prefix$drive_name
	if [[ -d $drive_dir/latest ]]
	   then excludes=   dirs_to_backup=$drive_dir/latest/.  where=
	   else excludes="--exclude=$drive_dir_prefix*
			  --exclude-from=$exclude_file"
		   problem="missing '$drive_dir/latest' snapshot symlink"
		solution_1="you can hit CTRL-C, and either: create symlink"
		solution_2="use 'dirs_to_backup' variable to check root drive"
		warn "$problem: $solution_1, or $solution_2"
		where=-root
	fi

	dir=${dirs_to_backup%% *}
	set_FS_type___from_path $dir
	set__inode_size__data_block_size__dir_block_size___from_path $dir
	type=$FS_type dirblock=$dir_block_size inode=$inode_size
	file=$type-dirblock=$dirblock-inode=$inode-$drive_name$where.$suffix
	TraceV 1 dirs_to_backup file

	[[ ! $debug_opt ]] ||
	   abort "use '-T 1' or '-t' instead of '-d' (-d only works with -f)"
	[[ $UID == 0 ]] || abort "need to use sudo"

	rsync --dry-run --verbose --recursive --relative \
		  $excludes		      \
		--include='*/' --exclude='*'  \
		      $dirs_to_backup  /tmp/  |
	   grep '^/' |
	   # head -n 100 |		# uncomment to speedup debugging
	   tr '\n' '\0' | xargs -0 ls --block-size=K -sd |
	   sed -r 's/^ *([0-9]+K) +/\1|/' | # pipe-separate fields
	   sort -t '|' -k1n,1 -k2	  | # for histogram & compression
	   awk  -F '|' '{ printf "%6s\t%s\n", $1, $2 }' | # more readable
	   bzip2 -9 > $file.partial.bz2 && mv $file.partial.bz2 $file.bz2
	   [[ $? == 0 && ${PIPESTATUS[0]} == 0 ]] ||
	      abort "something bad happened"
	}

	file=${file%.bz2}
	header $file

	set -- $(bzcat $file.bz2 | wc -l)
	declare -i dir_count=$1
	declare -i median_line=$dir_count/2
	set -- $(bzcat $file.bz2 | sed -n ${median_line}p)
	printf "\n%7s directories.\n" $dir_count
	bzcat $file.bz2 |
	awk '    { KB += $1; count += 1 }
	     END { printf "Average directory size is %.1f KB\n",
				KB/count }'

	echo -e " Median directory size is ${1%K} KB ...\n"
	$Trace
	(( $dir_count > 100 )) && {
	declare -i decile_count=$(( ($dir_count + 5) / 10 )) i
	declare -i decile_median_line=decile_count/2
	for i in {0..9}
	    do	set -- $(bzcat $file.bz2 | sed -n ${decile_median_line}p)
		echo "Decile $i has median directory size of ${1}B"
		decile_median_line+=decile_count
	done
	echo
	}

	echo "--> histogram of directory sizes <--"
	echo "  count size"
	echo "  ----- ----"
	bzcat $file.bz2 | cut -f1 | uniq -c | sort -nr | head
	echo -e "    ...\n"

	set__total_dir_MB__avg_dir_KB $file.bz2
	echo "BUT...  The actual drive-space consumed by a directory is"
	echo "the size of its directory block(s) plus the size of its inode:"
	space="$total_dir_MB MB/snapshot"
	  avg="$avg_dir_KB KB/dir"
	echo -e "\n  all directories consume $space ($avg)\n\n"
}

# -----------------------------------------------------------------------------

filesystem_geometry() {
	[[ ${1-} == -[aA] ]] && { local all_opt=$1; shift; } || local all_opt=
	local drive_dirs=$*

	run_df    $drive_dirs
	run_lsblk $drive_dirs
	echo

	local dash="------" dsh="---------------"
	local dash="======" dsh="==============="
	local    format="%-15s   %-8s%8s %8s %8s %8s %8s %8s\n"
	local f=$format strp="stripe " wdth="width  "
      printf "$f" ""   ""	""	""	""	"dir " "$strp"  "$strp"
      printf "$f" Mount	FS-type	sector	inode	block	block  "unit  "	"$wdth"
      printf "$f" $dsh ==$dash	$dash	$dash	$dash	$dash	==$dash	==$dash
	format=${format/\%25s/%-15s  %8s}
	local drive_dir
	for drive_dir in ${drive_dirs:-$(list_drive_dirs $all_opt)}
	    do	set_FS_type___from_path $drive_dir
		local  name=${drive_dir#$drive_dir_prefix}
		set_FS_device___from_path $drive_dir
		[[ -L $FS_device ]] &&
		set_absolute_path $FS_device && FS_device=$absolute_path
		[[ $FS_device == /dev/mapper/* ]] && dev= ||
		dev=$(echo $FS_device | sed 's@.*/@@; /^[^-]*$/s/[0-9]*$//')
		case $FS_type in
		    ( ext? )
			# output _sometimes_ contains SPACEs (e.g. for inode=)
			RunCmd sudo tune2fs -l $FS_device > $tmp_1
			[[ ! $dev ]] && sector= ||
			sector=$(< /sys/block/$dev/queue/physical_block_size)
			inode=$(sed -n 's/^Inode size:.* //p' $tmp_1)
			block=$(sed -n 's/^Block size:.* //p' $tmp_1)
			dir_block=$block
			sunit=
			swidth=
			;;
		    ( xfs  )
			RunCmd xfs_info $drive_dir > $tmp # $tmp_1
		       sector=$(sed -nr '/at/s/.* sectsz=([^ ]+) .*/\1/p' $tmp)
			inode=$(sed -nr '/^m/ s/.* isize=([^ ]+) .*/\1/p' $tmp)
			block=$(sed -nr '/^d/ s/.* bsize=([^ ]+) .*/\1/p' $tmp)
		    dir_block=$(sed -nr '/^n/ s/.* bsize=([^ ]+) .*/\1/p' $tmp)
			sunit=$(sed -nr '/swi/s/.* sunit=([^ ]+) .*/\1/p' $tmp)
		       swidth=$(sed -nr '/^ /s/.* swidth=([^ ]+) .*/\1/p' $tmp)
			sunit="$sunit blks"
		       swidth="$swidth blks"
			;;
		    (  *   )
			printf "%-15s   %s is unknown FS type\n" \
				$name	$FS_type
			continue
			;;
		esac
		printf "$format" $drive_dir $FS_type \
		    "$sector" "$inode" "$block" "$dir_block" "$sunit" "$swidth"
	done
	rm $tmp_1
}

# -----------------------------------------------------------------------------

# Here's how to setup a brand new drive to be an encrypted drive

# If brand new drive, find its device name with: ls -lt /dev/sd?
# Save the device name and drive name: device=/dev/sdX  drive=Y
# Verify it's a new drive (which has partition table): fdisk -l $device
# See if someone is using it: fuser -v $device
# cryptsetup luksFormat $device /etc/snapcrypt/keys/keyfile.bin
#   (be SURE you type "YES" not "yes")
# Make sure encryption succeeded: fdisk -l $device # want no partitions
# Then run: snapcrypt open $device $drive (mount will fail).
# Then create new rule in /etc/snapcrypt/drives.rules .
# If have existing backup drives that are no bigger, use copy-drive .

# mkfs [-f] [mkfs-opts] device [name]: mkfs 1st/smallest drive (see comments)
mkfs_backup_drive() {
	set_date_time
	line_1="if you're using a partition or LV that already has backups,"
	line_2="you can keep them, if you rename them as /Year-Mo-Da,Hr/ , "
	line_3="e.g. 'now' looks like /$date_time/ ; don't run 'mkfs',"
	line_4="just re-label the partition and change its record in /etc/fstab"
	line_5="(which is not needed if the partition is auto-mounted)."
	warn "$line_1\n   $line_2\n   $line_3\n   $line_4\n   $line_5"

	[[ ${1-} == -f ]] && shift || [[ $mkfs_cmd_opts == mkfs.xfs* ]] || {
	   echo "If this is your first or smallest drive, use the -f option;"
	   echo "otherwise, use the very-fast 'copy-drive' action instead."
	   abort_with_action_Usage
	} >&2
	mkfs_opts=$(echo " $*" | sed -r 's@^(.*) /dev/.*@\1@')
	set  --   $(echo " $*" | sed -r 's@.* /dev/@/dev/@')
	[[ $# == [12] ]] || abort_with_action_Usage
	local device=$1 name=${2-}
	TraceV 3 mkfs_opts device name
	[[ $device = /* ]] || device=/dev/$device
	[[ -b $device ]] || $IfRun abort "$device not a block device"

	if [[ $name ]]
	   then set_drive_name $name
	   else set_drive_name $device
	fi
	local name=$drive_name
	local drive_dir=$drive_dir_prefix$drive_name
	local _mkfs_cmd_opts=$mkfs_cmd_opts
	_mkfs_cmd_opts+=" $mkfs_opts"

	set_FS_label___from_mount_dir $drive_dir

	# Since most files are shared between many snapshots, most of our
	# inodes are directories; so directory size determines space usage, so
	# we should choose a block size that will result in the smallest space
	# usage by directories (unless we only backup files that change often,
	# and they're large enough that ext* needs to use indirect blocks).
	# On my Ubuntu laptop, 1 KB blocks result in roughly half the
	# directory drive space used by 2 KB blocks, so the default block size
	# is 1KB.  On HRDAG's Ubuntu server using XFS, 1 KB blocks and 2 KB
	# blocks result in the same amount of directory space usage (and 4 KB
	# results in 20% more), since most directories need 0 drive blocks
	# (because their contents fit in the inode); so 2 KB blocks are
	# optimal for XFS, since they'll result in better performance.

	# To determine your actual average directory size, e.g. for ext4:
	#    # choose a filesystem type with mkfs_cmd_opts= in configure.sh
	#    snapback mkfs -b 1024 <drive-name>	# first time, use smallest -b
	#    # configure dirs_to_backup= and excludes
	#    snapback run-backup <drive-name>
	#    snapback dir-sizes  <drive-name>
	#
	#    snapback mkfs -b 2048 <drive-name> # overwrite older FS
	#    ...
	# If the FS stores small dirs in the inode, you might mess with isize.

	# ALSO, by making the block size smaller with ext*, you'll be able to
	# have more inodes if you have a lot of small files, see:
	# https://askubuntu.com/a/1104944 .  Having small blocks might reduce
	# performance on a rotational hard drive (unless you're using extents
	# and rsync's --preallocate), but probably won't affect performance on
	# an SSD or flash memory stick (unless you're using ext* and you have
	# lots of files with indirect blocks).

	# this block of code is only relevant to ext*
	[[ $_mkfs_cmd_opts != mkfs.[^e]* ]] && {
	local block_size=1024		# optimal, see above long comment
	set -- $_mkfs_cmd_opts
	while [[ $# != 0 ]]
	   do	[[ $1 == -b       ]] && block_size=${2-}
		[[ $1 == -b[0-9]* ]] && block_size=${1#-b}
		shift
	done
	local valid_block_sizes="1024 2048 4096"
	is_arg1_in_arg2 $block_size $valid_block_sizes ||
	   abort "ext* block size must be one of: $valid_block_sizes"
	local blocks_per_inode=1
	let    bytes_per_inode=$blocks_per_inode*$block_size
	TraceV 3 block_size bytes_per_inode
	}

	# There's no need to store small-files or file's extended-attributes
	# in inodes: The extra blocks used for small-files or out-of-inode
	# extended-attributes will be shared between snapshots, since file
	# inodes are shared between snapshots.  So, we want small inodes.
	# EXCEPT: If most of the backed-up _directories_ have
	# extended-attribute-blocks, then select an inode size that will hold
	# the average set of extended-attributes.  If you want to backup
	# nanosecond timestamps or file creation time on ext*, then use >= 256;
	# otherwise, use 128.

	# https://lwn.net/Articles/645722/ : 4/15: fixed ext4 extent corruption
	# https://en.wikipedia.org/wiki/Linux_kernel#Releases_4.x.y
	if [[ $FS_type == ext4 && $(uname -r) > 4.2.7 ]]
	   then local ext4_extent_opt="-O extent"
	   else local ext4_extent_opt=
	fi

	set -- $_mkfs_cmd_opts
	local cmd=$1; shift; local opts=$*  log_opt=
	  if [[ $cmd == mkfs.xfs ]]
	   then FS_type=xfs
		[[ $(which mkfs.xfs) ]] || $IfRun abort "install xfsprogs"
		# The above comment predicts isize=256; but CRCs need size=512,
		# and 90% of HRDAG's server's dirs fit in a size=512 inode;
		# using isize=1024 resulted in 40% more directory drive space.
		# For servers with bigger dirs, experiment with different
		# mkfs opts (on your fastest drive) and the dir-sizes action.
		#
		# See much-earlier long comment for discussion of block size.
		[[ $opts == *"-b size="* ]] || opts+=" -b size=4096"
		[[ $opts == *"-n size="* ]] || opts+=" -n size=4096"
		[[ $opts == *"-i size="* ]] || opts+=" -i size=512"
		[[ $opts == *maxpct=*    ]] || opts+=" -i maxpct=0"
		mount_opts="$XFS_mount_options"
		type -t set_FS_external_log > /dev/null && # optional
			set_FS_external_log $FS_label &&
		logdev="logdev=$FS_external_log" &&
		log_opt="-l $logdev"  mount_opts=$mount_opts,$logdev
	elif [[ $cmd == mkfs.ext? ]]
	   then FS_type=${cmd#*.}
	elif [[ $cmd == mke2fs ]]
	   then FS_type=$(echo $opts | sed -r 's/.*\W-t\W*(\w+)\b.*/\1/')
		[[ $FS_type ]] || FS_type=ext4
	elif [[ $cmd != mk* ]]
	   then abort "the value of 'mkfs_cmd_opts' should start with 'mk'"
	   else abort "don't support '$cmd $opts', email $coder"
	fi
	#
	if ! [[ $FS_type == ext? && $debug_opt && $UID == 0 ]]
	   then local mkfs_debug_opt=
	   else local mkfs_debug_opt=-n
		warn "running mkfs.$FS_type in debug mode ..."
	fi
	if [[ $FS_type == ext? ]]
	   then opts+=" -v"
		[[ $opts != *-T* ]] && {
		[[ $opts != *-b* ]]	&& opts+=" -b $block_size"
		[[ $opts != *-i* ]]	&& opts+=" -i $bytes_per_inode"
		[[ $opts != *-I* ]]	&& opts+=" -I 128"	; }
		[[ $opts != *-m* ]]	&& opts+=" -m .1"
		[[ $opts != *extent* ]] && opts+=" $ext4_extent_opt"
		[[ $FS_type == ext4  ]] &&
		mount_opts="$extN_mount_options"
		type -t set_FS_external_log > /dev/null	&& # optional
			set_FS_external_log $FS_label	&&
		log_label=$(basename $FS_external_log)	&&
		$IfRun mke2fs -v -b $block_size -O journal_dev \
			 -L $log_label $FS_external_log &&
		log_opt="-J device=$FS_external_log"
	fi

	df -m | grep " $drive_dir$" &&
	  $IfRun abort "there's already a filesystem mounted on $drive_dir"
	[[ $FS_type == xfs && $opts == *' -N '* ]] || {
	[[ -d $drive_dir ]] &&
	  $IfRun abort "directory $drive_dir/ exists: is name '$name' in use?"
	df -m | grep "^$device[ 	]" &&
	  $IfRun abort "that device is mounted; to *DESTROY* its contents,
			first run: umount $device"
	}

	[[ $UID == 0 ]] || $IfRun abort "run with sudo"

	[[ $mount_opts ]] && mount_opts=,$mount_opts
	mount_opts=$common_mount_options$mount_opts
	rec="\n\n\tLABEL=$FS_label\t$drive_dir\t$FS_type\t$mount_opts 0 2"
	warn "sample record for /etc/fstab (optional with 'snapcrypt'):$rec"

	[[ $mkfs_debug_opt ]] && IfRun=
	cmd="$cmd $opts $log_opt $mkfs_debug_opt -L $FS_label $device"
	header "$cmd"
	RunCmd  $cmd
	[[ $mkfs_debug_opt ]] && IfRun=echo
	$IfRun mkdir -p $drive_dir
	RunCmd mount -v -t $FS_type -o $mount_opts $device $drive_dir

	rsync_time_dir=$drive_log_dir/$rsync_time_subdir
	mkdir -p $rsync_time_dir
	cd_ $rsync_time_dir
	set -- *.txt
	if [[ -e $1 ]]
	   then set_date_time -r .
		dir=.${date_time%,*}
		$IfRun mkdir -p $dir
		$IfRun mv -v *.txt $PWD/$dir/
	fi

	echo -e "\nTo populate newly-created drive, run:\n
	$_our_name update-drive $drive_name"

	warn "DON'T FORGET to add \`$name' to drive_name_regex= in $config_file"
	return 0
}

# -----------------------------------------------------------------------------

_assert_dst_big_enough() {

	local msg
	if set_device_KB___from_block_device $src_device
	   then declare -i src_KB=$device_KB
		set_device_KB___from_block_device $dst_device
		declare -i KB_missing=$(( src_KB - device_KB ))
		(( KB_missing > 0 )) || return 1
		declare -i MB=KB_missing/1024
		declare -i GB=MB/1024 &&
		msg="$dst_name's $dst_device is too-small by $MB MB ($GB GB)"
		abort "$msg;\n  specify -D to *not* use 'dd' (use dump/retore)"
	   else msg="$dst_device MUST be as-large as $src_name's $src_device"
		warn "the new $msg"
	fi
}

# --------------------------------------------

# these 3 variables are global variables initialized elsewhere
set__drive_name__FS_device__drive_dir__FS_label() {
	local name=$1 device=${2-}

	[[ $device$name ]] || abort "need 1 non-null argument"

	[[ $name == /dev/* ]] && device=$name && name=

	[[ $name ]] && set_drive_name $name && name=$drive_name
	[[ !  $device ]] &&
	   set_FS_label___from_mount_dir $drive_dir_prefix$name &&
	   set_FS_device___from_FS_label $FS_label && device=$FS_device
	[[ -b $device ]] || abort "$device is not a block device"

	if [[ ! $name ]]
	   then set_FS_label___from_FS_device $device
		name=$FS_label
	fi

	FS_device=$device
	set_drive_name $name
	drive_dir=$drive_dir_prefix$drive_name
	set_FS_label___from_mount_dir $drive_dir

	TraceV 1 device name drive_name FS_device drive_dir FS_label
}

# ---------------------------------

copy_backup_drive() {
	action_opts=
	while [[ ${1-} == -* ]] ; do action_opts+=" $1"; shift; done
	[[ $# != 0 ]] ||
	abort "[-f] [-D] [-M] [-F] {src_name | src_dev} {dst_name dst_dev | '' dst_dev | dst_name}"
	local src=$1 dst_name=$2 dst_device=${3-}

	[[ -t 1 ]] || $IfRun abort "don't use 'nohup', we'll run 'nohup'"

	$Trace
	set__drive_name__FS_device__drive_dir__FS_label $src
	local src_name=$drive_name
	local src_device=$FS_device
	local src_drive_dir=$drive_dir
	local src_FS_label=$FS_label

	set__drive_name__FS_device__drive_dir__FS_label "$dst_name" $dst_device
	local dst_name=$drive_name
	local dst_device=$FS_device
	local dst_drive_dir=$drive_dir
	local dst_FS_label=$FS_label

	set_FS_type___from_path $src_device
	if [[ $FS_type == xfs ]] || is_arg1_in_arg2 -D $action_opts # not 'dd'?
	   then warn "'dump | restore' can take weeks; it's probably better to run another 'mkfs', then enable backups plus run 'update-drive $dst_name'"
	   else _assert_dst_big_enough
		# show the user a sample fstab record
		IfRun=echo mkfs_backup_drive -f $dst_device $dst_name |&
		  # search for the last two fields in the fstab record
		  egrep -B 3 "[[:space:]][0-9]+[[:space:]]+[0-9]+[[:space:]]*$"
	fi

	set --	$our_path $our_opts finish-$action $action_opts \
		$src_device $src_drive_dir \
		$dst_device $dst_drive_dir
	local cmd=$*

	if [[ $debug_opt ]]
	   then header "$_our_name ${cmd#* }"
		exec $cmd || abort "$cmd -> $?"
	fi

	local output_file=$dst_FS_label.out
	echo -e "
	nohup'ing commands to copy partition '$src_name' to '$dst_name';
	this takes about a day per TB of drive space.  Now running
	'exec tail -f $output_file'; you can hit CTRL-C when you get bored.
	"
	nohup $cmd > $output_file &
	local copy_PID=$!
	sleep 0.1; set -x; exec tail --pid=$copy_PID -f $output_file
}

# ------------------------------------------------------------------

_prepare_for_dump_restore() {
	if [[ ${1-} == -S ]]		# src doesn't need to be mounted?
	   then is_drive_mounted $src_drive_dir || local src_name=
		local src_drive_dir=
	fi

	local FS_type src_FS_type
	set_FS_type___from_path $src_device
	src_FS_type=$FS_type
	set_FS_type___from_path $dst_device
	[[ $src_FS_type == $FS_type ]] ||
	   $IfRun abort "FS_type of $dst_device must be '$src_FS_type'"

	assert_not_in_cron_jobs $src_name $dst_name

	local drive
	for drive in $src_drive_dir $dst_drive_dir
	    do	is_drive_mounted $drive || $IfRun abort "mount drive $drive"
	done

	kill_all_jobs $src_name $dst_name

	if [[ ${drive_name_regex-} ]]
	   then local where=drive_name_regex=
	   else local where=cron
	fi
	warn "as soon as dump finishes, you can add it back to $where"
}

# ---------------------------------

show_iostat() {
	local device=$1

	$IfRun iostat -y -m -d $device | grep -v -e '^Linux' -e '^$'
}

# ---------------------------------

_dump_restore_xfs_backup_drives() {

	_prepare_for_dump_restore

	$IfRun set -x

	$IfRun xfs_freeze -f $src_drive_dir

	if [[ -d $dst_drive_dir/xfsrestorehousekeepingdir ]]
	   then local restore_opt=-R
	   else local restore_opt=
	fi

	trap '' INT			# don't interrupt xfsdump or xfsrestore
	show_iostat $dst_device
	time $IfRun    xfsdump -J -p 600       - $src_drive_dir |
	     $IfRun xfsrestore -J $restore_opt - $dst_drive_dir
	local status=$?
	show_iostat $dst_device

	$IfRun xfs_freeze -u $src_drive_dir

	return $status
}

# ---------------------------------

_dump_restore_extN_backup_drives() {

	_prepare_for_dump_restore -S

	have_cmd dump || abort "need to install the 'dump' command"

	$IfRun set -x

	# https://stackoverflow.com/questions/37488629/how-to-use-dump-and-restore-to-clone-a-linux-os-drive
	cd_ $dst_drive_dir
	trap '' INT			# don't interrupt dump or restore
	show_iostat $dst_device
	time $IfRun   dump -a0f - $src_device |
	     $IfRun restore -rf -
	local status=$?
	show_iostat $dst_device

	return $status
}

# --------------------------------------------

_copy_extN_backup_drive() {

	is_arg1_in_arg2 -f $action_opts ||
	for drive_dir in $src_drive_dir $dst_drive_dir; do
	if is_drive_mounted $drive_dir
	   then set -- $(list_drive_dirs |
			 fgrep -v -w -e $src_drive_dir -e $dst_drive_dir)
		[[ $# == 0 ]] &&
		msg="
	There are no other backup partitions mounted besides the ones used to
        copy $src_drive_dir to $dst_drive_dir ; if you let me unmount these
	partition(s), no new backups will be made for many hours (or days).

	You might instead run '$_our_name mkfs' on the new drive, leave the old
	drive mounted, and run:

		cd $src_drive_dir
		nohup rsync -aSHX * $dst_drive_dir/ &

	To instead unmount both drives and do a fast 'dd'," ||	msg="
	$src_drive_dir is mounted;"
		abort "\n$msg re-run copy-drive with -f to Force unmount."
	fi; done

	unmount_drives -q $src_drive_dir $dst_drive_dir ||
	   $IfRun abort "unmount the drive that failed to 'umount'"

	# -------------------------------------------------------

	$IfRun set -x
	time RunCmd dd if=$src_device of=$dst_device bs=1M
	[[ $Trace ]] || set +x

	$IfRun tune2fs -U $(uuidgen) $dst_device

	label_drive $dst_device $dst_drive_dir

	if sudo tune2fs -l $src_device | grep -q "^Journal dev" || # external?
	   [[ $do_want_external_log ]]
	   then add_extN_journal -M $dst_name $dst_device ||
		   abort "need to fix journal on $src_device: $_our_name aej"
	fi

	local mount_options=$common_mount_options,$extN_mount_options
	mount_options=${mount_options%,}

	is_arg1_in_arg2 -M $action_opts || # don't want to re-Mount src?
	RunCmd mount -v -t $FS_type -o$mount_options $src_device $src_drive_dir

	is_arg1_in_arg2 -F $action_opts || # don't want Fsck?
	time RunCmd -m "better check $src_device ?!" \
	e2fsck -f -p -t -t $dst_device

	$IfRun mkdir -p $dst_drive_dir
	RunCmd -m "make mount happen, then run resize2fs" \
	mount -v -t $FS_type -o $mount_options $dst_device $dst_drive_dir

	RunCmd resize2fs $dst_device	# do this _after_ mount, for speed
}

# --------------------------------------------

# finish-copy-drive: copy, label & UUID, replace journal, fsck, mount, resize
finish_copy_backup_drive() {
	action_opts=
	while [[ ${1-} == -* ]] ; do action_opts+=" $1"; shift; done
	local cmd=$(echo "$Usage" |
		    grep copy-drive | sed "s/^ */$_our_name -d /; s/:.*//")
	[[ $# == 4 ]] || abort "to see args, run: $cmd"

	local src_device=$1 src_drive_dir=$2
	local dst_device=$3 dst_drive_dir=$4

	local src_name=${src_drive_dir#$drive_dir_prefix}
	local dst_name=${dst_drive_dir#$drive_dir_prefix}

	suspend_tracing
	customize_and_validate_configuration_variables $dst_name
	restore_tracing dst_name

	[[ $UID == 0 ]] || $IfRun abort "run with sudo"

	set_FS_type___from_path $src_device
	case $FS_type in
	   ( ext?) if is_arg1_in_arg2 -D $action_opts
		      then _dump_restore_extN_backup_drives
		      else _copy_extN_backup_drive
		   fi ;;
	   ( xfs ) _dump_restore_xfs_backup_drives  ;;
	   (  *  ) abort "write FS function call for $FUNCNAME, email $coder";;
	esac ||
	   abort "the copy seems to have failed with $?, check .out file"
	set +x

	local var=drive_name_regex
	warn "DON'T FORGET: add $src_name & $dst_name to $var= in $config_file"

	return 0
}

##############################################################################-
##############################################################################-
# Random maintenance functions.
##############################################################################-
##############################################################################-

check-snapshot-hard-links() {
	local name=$1

	[[ ${very_old_immutable_files-} ]] ||
	   abort "setup very_old_immutable_files= in $config_file"

	set_drive_name $name
	set_drive_dir  $drive_name
	cd_ $drive_dir

	set_inum() {
		[[ -r $1 ]] || abort "run with sudo"
		set -- $(ls -i -d $1 2>/dev/null)
		inum=$1
		[[ $inum ]]
	}

	set -- $snapshot_pattern*

	declare -A file2inum
	for old_file in $very_old_immutable_files
	    do	$IfRun sudo -n chattr +i $old_file &> /dev/null # optional
		file=$1$old_file
		set_inum $file ||
		  abort "$drive_name: $file missing from oldest snapshot $1"
		file2inum[$old_file]=$inum
	done
	$Trace
	partials=
	while [[ $# != 0 ]]
	    do	found_good_link=$false
		for old_file in $very_old_immutable_files
		    do	old_inum=${file2inum[$old_file]}
			set_inum $1$old_file
			[[ $old_inum == $inum ]] || continue
			found_good_link=$true
			break
		done
		[[ $found_good_link ]] && partials= && shift && continue
		[[ $1 == *.partial  ]] && partials+=" $1" &&
						       shift && continue

		$IfRun mkdir -p .rm
		set -- $partials $*
		warn "$drive_name: the following have broken hard-links: $*"
		exit 1
	done
	echo "$drive_name: no broken hard-links!"
}

# -----------------------------------------------------------------------------
# regression tests for "old" (installed) vs "tst" (workspace) snapback
# -----------------------------------------------------------------------------

was_test_cache_stale=

# -d is used to specify a comma-separated list of Drives
# -r means using data on a Real backup drive
is_test_cache_stale() {
	[[ $1 == -d ]] && { local drives=$2 ; shift 2; } || local drives=
	[[ $1 == -r ]] && { is_debug_drive= ; shift; } || is_debug_drive=$true
	[[ $1 != -* ]] || abort "unknown option $1 (order matters)"
	local cached_file=$1

	was_test_cache_stale=$true	# assume cached file is stale

	[[ -s $cached_file ]] || return 0

	for file in $old_cmd $config_file
	    do	[[ $cached_file -nt $file ]] && continue
		echo "$file is newer, recomputing ..."
		return 0
	done

	local drive
	if [[ $is_debug_drive ]]
	   then drives=${drive_dir_prefix}Z
	elif [[ $drives ]]
	   then _drives=
		for drive in ${drives//,/ }
		    do	_set_drive_name $drive
			 drive=$drive_dir_prefix/$drive_name
			_drives+=" $drive"
		done
		drives=${_drives# }
	   else drives=$(snapback list-drives -a)
	fi

	for drive in $drives
	    do	[[ $cached_file -nt $drive/. ]] && continue
		echo "$drive is newer, recomputing ..."
		return 0
	done

	was_test_cache_stale=$false	# we found no problems

	return 1
}

# --------------------------------------------

show_test_header() {
	header "$* (first number is sorted md5sum, second is unsorted)"
}

# ---------------------------------

show_test_results() {
	local output_file=$1

	echo "$(sort $output_file | md5sum) $(md5sum $output_file)"
}

# --------------------------------------------

run_debug_cmds() {
	local test=$1; shift
	local args=$*

	local tmp_o=$tmp_dir/o$test	# holds output from "old" cmd
	local tmp_t=$tmp_dir/t$test	# holds output from "tst" cmd

	is_test_cache_stale $is_test_cache_stale_opts  $tmp_o &&
	$old_cmd -d $args &> $tmp_o ; show_test_results $tmp_o
	$tst_cmd -d $args &> $tmp_t ; show_test_results $tmp_t
	cmp --quiet $tmp_o $tmp_t && { echo "-- same results!"; return; }

	[[ $was_test_cache_stale ]] || {
	echo -e "\nSince different results, we'll regenerate cached data ..."
	$old_cmd -d $args &> $tmp_o ; show_test_results $tmp_o
				      show_test_results $tmp_t
	cmp --quiet $tmp_o $tmp_t && { echo "-- same results!"; return; }
	}

	echo "-- DIFFERENT results, compare with: diff -u $tmp_o $tmp_t"
}

# ---------------------------------

regression_test() {
	local tests=${*:-b c z p u}

	[[ -x $old_cmd ]] || abort "fix old_cmd= in $config_file"
	[[ -x $tst_cmd ]] || abort "fix tst_cmd= in $config_file"

	# --------------------------------------------

	is_arg1_in_arg2 b $tests && {
	show_test_header backup all
	is_test_cache_stale_opts=-r	# we backup all drives ...
	run_debug_cmds b run-backups all
	}

	# --------------------------------------------

	is_arg1_in_arg2 c $tests && {
	show_test_header copy to Z
	is_test_cache_stale_opts=    # will use oldest snapshot, never deleted
	set_oldest_snapshot
	run_debug_cmds c copy-snapshot $oldest_snapshot Z
	}

	# --------------------------------------------

	is_arg1_in_arg2 z $tests && {
	set -- ${drive_dir_prefix}Z/$snapshot_pattern
	(( $# > 10 )) || $our_path test-prune || abort "can't setup Z"
	show_test_header prune Z
	is_test_cache_stale_opts=	# test-prune always leaves same files
	run_debug_cmds z prune-drive Z
	}

	# --------------------------------------------

	is_arg1_in_arg2 p $tests && {
	show_test_header prune all
	is_test_cache_stale_opts=-r	# we prune all drives ...
	run_debug_cmds z prune-drives all
	}

	# --------------------------------------------

	is_arg1_in_arg2 u $tests && {
	local src=${update_test_src-}
	local dst=${update_test_dst-}
	[[ $src && $dst ]] ||
	   abort "$config_file needs update_test_src & update_test_dst for 'u'"
	show_test_header update -s $src $dst

	_set_drive_name $dst
	ps_locks copy > /dev/null &&
	$our_path kill-copy $dst &> /dev/null &&
	    warn "killed update-drive (or copy) to $dst"

	is_test_cache_stale_opts="-d $src,$dst"
	run_debug_cmds u update-drives -s $src $dst
	}

	echo
}

#############################################################################
#############################################################################
# Process the requested action with the above functions & global variables. #
#############################################################################
#############################################################################

[[ $# != 0 ]] || abort "specify an action to perform\n$Usage"

action=$1; shift
_our_name="$our_name"
 our_name="$our_name $action"
undo_action_abbrev() { readonly action=$1 our_name="$_our_name $1" _our_name; }

# ---------------------------------

process_action() {

stack_frame_to_show=0		# show line-number inside the 'case' statement

case $action in
  # list-drives [-a]: list mounted backup drives; -a adds drives cron ignores
   ( l*s*dr*v* | ld | ls | df ) undo_action_abbrev list-drives
	list_drive_dirs "$@"
	;;
   # run-backups   names: backup names ('all' for every mounted backup drive)
   ( r*b*k*p* | rb* ) undo_action_abbrev run-backups
	[[ $# != 0 ]] || abort_with_action_Usage
	[[ $1 == all ]] && rm_stale_locks
	run_jobs_in_parallel backup "$@"
	[[ ! $is_cron ]] || wait	# so see master cron job in ps
	;;
  # prune-drives  names: prune  names ('all' for every "" ""); see configure.sh
   ( pr*n*dr*v* | pd* ) undo_action_abbrev prune-drives
	[[ $# != 0 ]] || abort_with_action_Usage
	run_jobs_in_parallel prune "$@"
	[[ ! $is_cron ]] || wait	# so see master cron job in ps
	;;
   # update-drives [-d] [-s src-names-regex] dst-names: copy missing snapshots
   ( upd*dr*v* | u*d* ) undo_action_abbrev update-drives
	[[ $1 == -d  ]] && {  debug_copy=$1; shift; } ||  debug_copy=
	[[ $1 == -s  ]] && { src_names_regex_opt="$1$2"; shift 2; }
	[[ $1 == -s* ]] && { src_names_regex_opt="$1"  ; shift  ; }
	[[ $1 == -r  ]] && { recurse_opt=$1; shift; } || recurse_opt=
	[[ $1 != -*  ]] || abort "unknown option $1 (order matters)"
	[[ $# != 0   ]] || abort_with_action_Usage
	run_jobs_in_parallel update ${src_names_regex_opt-} $recurse_opt $*
	# [[ ! $is_cron ]] || wait	# so see master cron job in ps
	;;
   # NOTE: this must appear before copy-snapshots (it has 'cs' as a shortcut)
   # check-snapshot-hard-links names: find snapshots with broken hard links
   ( c*s*h*l* ) undo_action_abbrev check-snapshot-hard-links
	[[ $# != 0   ]] || abort_with_action_Usage
	[[ $1 == all ]] && set -- $(list_drive_dirs)
	for drive
	    do	check-snapshot-hard-links $drive
	done
	;;
   # copy-snapshots [-d] [-q] snapshots name: copy to 'name' mounted drive
   ( c*p*s*s* | cs* | cps ) undo_action_abbrev copy-snapshots # cpss
	[[ $1 == -r ]] && { run_copy_job "$@"; exit $?; }
	[[ $1 == -d ]] && { debug_copy=$1; shift; } || debug_copy=
	[[ $1 == -q ]] && {  quiet_opt=$1; shift; } ||  quiet_opt=
	[[ $1 != -* ]] || abort "unknown option $1 (order matters)"
	(( $# >= 2  )) || abort_with_action_Usage
	drive_name=${!#}
	src_snapshots=${*%$drive_name}

	set_drive_name $drive_name

	lock copy || exit 1
	for snapshot in $src_snapshots
	    do	copy_snapshot $quiet_opt $snapshot $drive_name
	done
	unlock copy
	;;

  # snapshot-size dir: size of non-hard-linked files (ie in no other snapshots)
   ( snapshot*size | ss ) undo_action_abbrev snapshot-size
	[[ $# == 1 ]] || abort_with_action_Usage
	dir=$1
	[[ -d $dir ]] || abort "dir '$dir' doesn't exist"
	warn "this could take hours"
	$Trace
	KB=$(sudo find $dir -links 1 -printf '%k\n' |
		awk '{ total += $1 } ; END { print total }')
	set_readable_du_size $KB
	du_size=$readable_du_size
	echo "$dir contains >= $du_size of files in no other directories"
	;;

   # w: show pruning & backup activity, and the status of pruning and backups
   # watch [-f][-C][-N names] [watch opts]: 'watch w' (-f: wide; -C: cron jobs)
   ( watch | wa* | wt* | w ) [[ $action == w?* ]] && undo_action_abbrev watch
	watch "$@"
	;;

   # kill-backup [-sig] names: for each name (can be 'all'), kill backup job
   ( kill-backup* | kb ) undo_action_abbrev kill-backup
	[[ $# != 0 ]] || abort_with_action_Usage
	$Trace
	kill_jobs backup $*
	;;
   # kill-prune  [-sig] names: for each name (can be 'all'), kill prune job
   ( kill-prune* | kp ) undo_action_abbrev kill-prune
	[[ $# != 0 ]] || abort_with_action_Usage
	$Trace
	kill_jobs prune $*
	;;
   # kill-copy   [-sig] names: for each name (can be 'all'), kill copy/update
   ( kill-copy* | kc | ku ) undo_action_abbrev kill-copy
	[[ $# != 0 ]] || abort_with_action_Usage
	$Trace
	kill_jobs copy $*
	;;
   # kill-all    [-sig] names: for each name (can be 'all'), kill all jobs
   ( kill-all | ka | kk ) undo_action_abbrev kill-all
	[[ $# != 0 ]] || abort_with_action_Usage
	$Trace
	kill_all_jobs $*
	;;
   # ps [ps-opts] [type-pattern [name-pattern]]: show holders of lock(s)
   ( ps )
	ps_locks "$@"
	;;

   ###########################################################################
   # filesystem maintenance actions
   ###########################################################################

   ( add*extN*journal | aej ) undo_action_abbrev add-extN-journal
     add_extN_journal "$@"
	;;

   ( dir*sizes | ds ) undo_action_abbrev dir-sizes
     dir_sizes "$@"
	;;

   # filesystem-geometry [-a|-A|drive-dirs]: show sector, inode, block, etc
   ( filesystem*geometry | fsg ) undo_action_abbrev filesystem-geometry
     filesystem_geometry "$@"
	;;

   # mkfs [-f] [mkfs-opts] device name: run mkfs optimized for many snapshots
   ( mkfs )
     mkfs_backup_drive "$@"
	;;
   # copy-drive {src_name | src_dev} dst_name [dst_dev]: duplicate backup drive
   ( c*p**dr*v* | cpd ) undo_action_abbrev copy-drive
     copy_backup_drive "$@"
	;;
   # finish-copy-drive: only used internally
   ( f*c*p*dr*v* | f*c*p*d* | fcd ) undo_action_abbrev finish-copy-drive
     finish_copy_backup_drive "$@"
	;;

   ###########################################################################
   # Actions for regression tests.
   ###########################################################################

   # mk-Z [date [period]]: create mostly-empty snapshot dirs in Z mount-point
   ( mk*[Zz] | mkz ) undo_action_abbrev mk-Z
	[[ $1 == -q ]] && { is_quiet=$true; shift; } || is_quiet=$false
	[[ $1 != -* ]] || abort "unknown option $1"

	# The following designed to work with (custom) configure.sh span of 1,
	#    and are memorialized in action test-prune.
	# Test pruning of hours: snapback mk-Z 12/22/2099 0..23 # 0, 2 seconds
	#    ...  days & months: snapback mk-Z 1/1/2094   0	 # 5,14 seconds
	#    ... months & years: snapback mk-Z 1/1/2010   month # 58,8 seconds

	# 1/1/2010 is earliest day, earlier days (e.g. 091231) look like octal
     readonly end_date="1/1/2100"	# keep constant, so can compare
	    start_date=${1:-12/22/2099}	# tests hours with ...
	        period=${2:-0..23}	# sequence of hours, else 'month'

	set_drive_dir Z
	cd_ $drive_dir
	[[ $debug_opt ]] ||
	rm -rf *

	hours=00 is_months=$false
	case $period in
	    ( 0 ) ;;
	    ( month* ) is_months=$true ;;
	    ( * ) eval "set -- {$period}" ; hours=$* ;;
	esac

	declare -i start_secs=$(date -d "$start_date" '+%s')
	declare -i   end_secs=$(date -d   "$end_date" '+%s')
	declare -i secs=start_secs secs_per_day=24*60*60
	let end_secs-=3600		# end at 11 PM on previous day
	while  ((  secs < end_secs ))
	   do	set_day $secs
		secs+=secs_per_day
		[[ $day == *01 || ! $is_months ]] || continue
		[[ $day != 0* ]] || abort "start date must be after 1/1/2010"
		for hour in $hours
		    do	[[ $hour == ? ]] && hour=0$hour
			snapshot=$day,$hour
			[[ -d $snapshot ]] || echo $snapshot
		done
	done | xargs -r $IfRun mkdir || abort mkdir

	# setup partial snapshots mid-date, to test pruning
	declare -i mid_secs="start_secs+(end_secs-start_secs)/2"
	set_day $mid_secs; mid_day=$day
	TraceV 7 start_date mid_day end_date
	for hour in 00 02 04 08 09 12
	    do	for ext in links partial
		    do	snapshot=$mid_day,$hour.$ext
			$IfRun mkdir -p $snapshot
		done
	done

	set_day $start_secs
	snapshot=$day,00
	for subdir in /var/repos/snap.test ~/{tmp,git/pylint}
	    do	bad_dir=$snapshot$subdir/deleteme
		$IfRun mkdir -p $bad_dir
		$IfRun touch    $bad_dir/deleteme.txt
	done
	[[ $is_quiet ]] ||
	Trace 0 "created excludable-junk in $snapshot"

	# there was something else that needed to be tested??
	for file in
	    do	true
	done

	$IfRun rm -rf .mk-Z
	$IfRun mkdir  .mk-Z	; [[ $debug_opt ]] ||
	cp -al *    .mk-Z/
	;;

   # test-prune: use mk-Z to run pruning regression test in the Z pseudo-drive
   ( test*prune | tp ) undo_action_abbrev test-prune
	[[ $# == 0 ]] || abort_with_action_Usage

	[[ $UID != 0 ]] || abort "do not run this as root"

	customize_and_validate_configuration_variables Z

	cmd_dirs="/usr/local/bin/ ~/git/$_our_name/bin/"
	echo -e "\nComparing prune results using '$_our_name' in:
	${cmd_dirs/ / vs }"
	set_drive_dir Z

	# see the comment at the top of the mk-Z option, above
	declare -A prune_type2mk_Z_args=(
	      [hour]="12/22/2099 0..23"
	 [month-day]="1/1/2094 0"
	[year-month]="1/1/2010 month"
	)

	clone_stashed_mk_Z() {
		local type=$1 stash=.mk-Z.$1
		suspend_tracing
		rm -rf $snapshot_pattern* la* && cp -al $stash/* . ||
		   abort "failed to clone $stash"
		restore_tracing
	}

	$Trace
	cd_ $drive_dir
	for type in $(echo ${!prune_type2mk_Z_args[*]} | tr ' ' '\n' | sort)
	    do	mk_Z_args=${prune_type2mk_Z_args[$type]}
		header "prune '$type' snapshots, created by: mk-Z $mk_Z_args"
		stash=.mk-Z.$type
		$IfRun rm -rf $stash.*.ls
		[[ ! -d $stash ]] && {
		$IfRun $our_path mk-Z -q $mk_Z_args &&
		   $IfRun mv .mk-Z $stash && $IfRun rm -f $stash/latest ||
			abort "couldn't populate $stash"; }
		for dir in $cmd_dirs
		    do	eval "dir=$dir"	# expand ~
			$IfRun clone_stashed_mk_Z $type
			$IfRun $dir$_our_name $our_opts prune-drive Z |&
			   fgrep -v ' prune-drive Z: pruned '
			[[ $dir == /usr/* ]] && cmd=old || cmd=new
			ls > $stash.$cmd.ls
		done
		set -- $(echo $stash.*.ls | sort -r)
		diff -q $* && mv $stash.new.ls $stash.pruned.ls &&
			      rm $stash.old.ls &&
		   echo -e "\nSame results, see $stash*" && continue
		warn "regression, see: diff -u $*"
	done

	clone_stashed_mk_Z hour
	echo -e "\nLeft a lot of unpruned snapshots in Z, for other testing."
	;;

   # regression-test [tests]: check functionality, see $tmp_dir/?? for results
   ( r*t* ) undo_action_abbrev regression-test; $Trace
	regression_test "$@"
	;;

   ###########################################################################
   # actions for snapcrypt to call
   ###########################################################################

   # WARNING: this should only be called by "snapcrypt close"
   # unmount names: for each name (can be 'all'), kill backup & unmount drive
   ( u*mount | u ) undo_action_abbrev unmount # umount
	[[ $# != 0 ]] || abort "pass drive names"
     unmount_drives "$@"
	;;
   # for "snapcrypt close": don't eject if didn't get any backups today
   ( has*new*snapshots | hsn ) undo_action_abbrev has-new-snapshots
	drive=$1
	[[ $drive == *Z ]] && exit 0	# for debugging

	$Trace
	is_drive_mounted $drive || exit 0
	suspend_tracing
	set -- $drive/$snapshot_pattern	# all the _successful_ snapshots
	restore_tracing
	latest_snapshot=${!#}
	[[ -d $latest_snapshot ]] ||
	    abort "$drive has no (successful) snapshots"
	latest_date_time=$(basename $latest_snapshot)
	latest_day=${latest_date_time%,??}
	# let latest_day=latest_day-1		# uncomment to debug
	set_date_time
	day=${date_time%,??}
	[[ $latest_day == $day ]] ||
	    abort "$drive has no (successful) backups since $latest_day"
	;;
   # for "snapcrypt close": find drive with max # snapshots since last mounted
   ( max*drive | max*backup* | md | mb ) undo_action_abbrev max-drive
	if [[ $# == 1 ]]
	   then set_drive_name $1 2>/dev/null
		if [[ ${drive_name-} ]]
		   then echo "$drive_dir_prefix$drive_name"
			exit 0
		fi
	fi

	set -- ${*:-$(list_drive_dirs)}	# for debugging: | tac
	[[  -d $1  ]] || shift
	[[ $# != 0 ]] || abort "no backup drives are mounted"

	declare -i secs_per_day=24*60*60
	$Trace
	max_drive=$1; shift
	while [[ $# != 0 ]]
	    do	new_drive=$1
		for (( secs=$(date '+%s'); 1; secs-=secs_per_day ))
		    do	set_day $secs

			set -- $new_drive/$day,??*
			[[ -d $1 ]] || break

			set -- $max_drive/$day,??*
			[[ -d $1 ]] && continue
			max_drive=$new_drive
			break
		done
		shift
	done
	echo $max_drive
	;;
   # for "snapcrypt": echo drive mountpoint
   ( drive )
	_set_drive_name $1
	echo $drive_dir_prefix$drive_name
	;;

   # -------------------------------------------------------------
   # this final action has random tests used during development; #
   # you can jump to the end of the file.			 #
   # -------------------------------------------------------------

   ( run | r ) undo_action_abbrev run
	run_function "$@"		# can pass: -v "varname(s)"
	;;
   ( test | t ) undo_action_abbrev test; $Trace
	load__drive_name2do_suspend
	set -- $drive_dir_prefix*/$snapshot_day_pattern,00
	fastest_snapshots $drive_dir_prefix*/${1##*/} # oldest snapshot
	exit

	set_absolute_path /dev/mapper/backup_C
	echo $absolute_path
	exit

	set -- $drive_dir_prefix${1^^}/$snapshot_pattern*
	new_snapshot=$1
	TraceV 0 new_snapshot
	_have_full_snapshot
	echo "status=$?"
	exit

	cleanup_after_updates
	exit

	set_drive_name "$@"
	set_drive_dir $drive_name
	remove_empty_partial_snapshots $drive_dir
	exit

	sorted_useful_srcs "$@"
	exit

	count_rsyncs_using_resource $1
	echo $?
	exit

	echo $$
	lock prune G
	echo $?
	exit

	lock backup x
	lock backup x || abort badness 1
	unlock backup
	unlock backup && abort badness 2
	exit

	lock backup x
	lock backup x || abort badness 1
	lock backup y && abort badness 2
	exit

	declare -a digit2name=(zero one two three)
	echoEV action digit2name[2]
	exit

	$Trace
	customize_config_variables ${1:-G}
	exit

	validate_config_variables
	set__OS_release_file__OS_release
	TraceV 0 OS_release_file OS_release
	exit

	log test 1
	customize_and_validate_configuration_variables Z
	echo $drive_name
	log test 2
	exit

	copy_snapshot 1 2 3
	exit

	set_FS_label___from_FS_device foo
	exit

	set_FS_block_size___from_path $1
	echo $FS_block_size
	exit

	for dev in $(df | cut -d' ' -f1)
	    do	[[ -b $dev ]] || continue
		set_FS_label___from_FS_device $dev
		echo "$dev -> $FS_label"
	done
	exit

	for path in ${drive_dir_prefix}A ${drive_dir_prefix}A/latest /dev/sdb5
	    do	set_FS_type___from_path $path
		echo "$path -> $FS_type"
	done
	exit

	set_drive_name ${1:-a}
	set_drive_dir $drive_name
	set_FS_label___from_mount_dir $drive_dir
	echo $FS_label
	exit

	print_call_stack 1
	abort test

	set_drive_name ${1:-a}
	TraceV 0 drive_name file_for_logging log_msg_prefix
	echo  test1
	echoE test2
	log 0 test3
	abort test4
	exit

	echoE test
	foo() {
		echoE ftest
		for  i  in ${!FUNCNAME[*]}
		   do	echo "FUNCNAME[i]=${FUNCNAME[$i]}"
		done
		echoEV   i
		TraceV 0 i i
		abort "aborting test"
	}
	foo
	exit

	set_drive_dir ${1^}
	$Trace
	is_drive_usage_too_high
	abort $?

	set_oldest_snapshot
	echo $oldest_snapshot
	exit

	for size in 1023 1024 2123123 3123123123 4123123123123 5123123123123123
	    do	set_readable_du_size $size; echo "$readable_du_size from $size"
	done
	exit

	drive_dir=${drive_dir_prefix}F
	cd $drive_dir
	log=/tmp/root/F-190126-15.bz2
	_links_error_msg "nnn 'Too many links'"
	exit

	$Trace
	set_drive_dir ${1-''}
	log "test with drive ${1-}"
	exit
	;;

   ( * )
	warn "'$action' is not a recognized action, run: $_our_name -h"
	exit 1
	;;
esac

}

process_action "$@"
