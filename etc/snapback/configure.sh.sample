# version=14

################################################################
################################################################
### This file and exclude.txt specify backup & prune policy. ###
### Email requests for more variables to sweikart@gmail.com  ###
################################################################
################################################################

renice 1 $$ &> /dev/null		# lower priority than logins

##############################################################################
# Most variables can have per-drive values (must remove -r or readonly label),
#   using either source_drive_specific_config_file (which can be modified) or
#   eg: drv_name2dirs_to_backup[Z]=/var/tmp/small-dir  # test w/pseudo-drive Z
##############################################################################

# -----------------------------------------------------------------------------
# The command + options used by action 'mkfs' to create a brand new filesystem.
# -----------------------------------------------------------------------------

# --------------------------
# To understand the defaults mentioned below, read the long comments in
# mkfs_backup_drive and it's helper functions.
# --------------------------

# Comment-out all-but-one of these sample values:

# You'll need to add -f if the partition already has an *UNWANTED* filesystem.
# sparse=1 may hurt performance on hard disk drives (but probably not SSDs).
# The default: -i maxpct=0 -i size=512 -s size=2048 -b size=2048 -n size=2048
# (sector/block sizes of 2048 allow ~20% more snapshots than 4096); note
# that you can over-ride any of these individual defaults.
readonly mkfs_cmd_opts="mkfs.xfs" # XFS needed if apps use many hard-links

# Defaults to opts="-b 1024 -i 1024 -I 128 -m .1"; you can override them,
# but first read the long comments in the mkfs_backup_drive function & helpers.
# Defaults to extent-based if new-enough kernel, override with "-O ^extent".
readonly mkfs_cmd_opts="mkfs.ext4"	# typical GNU/Linux server or laptop
readonly mkfs_cmd_opts="mkfs.ext4 -b 2048" # if action 'dir-sizes' suggests

# SSDs have no seek penalty, so can run an rsync backup and deletion of pruned
# snapshots simultaneously with no I/O penalty (the priority is controlled as
# described later).  Hard disks are different, so you can change that policy.
	 suspend_prune_when_backup=$true     # non-RAID hard-disk drive
drv_name2suspend_prune_when_backup[C]=$false # SSD or flash memory stick
#
# The above and the below are correlated.
#
# Used by set_FS_external_log: should it setup an external filesystem journal?
	 do_want_external_log=$true	# rotational disk, & have SSD for logs
drv_name2do_want_external_log[C]=$false # SSD

# Optional function to allowcate an external filesystem log/journal
# on fast storage (RAID, SSD, even flash memory stick).
false &&				# rewrite function if not using LVM
set_FS_external_log() {
	[[ ${1-} == -f ]] && { do_force=$true; shift; } || do_force=$false
	local FS_label=$1 VG=${2:-VGfast} # default VG: fast & reliable

	[[ $do_want_external_log ||	# defined later in this file
	   $do_force                ]] || { FS_external_log= && return 1; }

	       FS_external_log=/dev/$VG/${FS_label}_log
	[[ -b $FS_external_log ]] && return 0

	$IfRun lvcreate --size 128M --name $FS_external_log $VG ||
	    FS_external_log=
	[[ $FS_external_log ]]
}

# You probably won't need to change these.
readonly common_mount_options="nodev,nosuid,relatime,nodiratime"
readonly   extN_mount_options="journal_checksum" # for reliability (for ext4)
readonly    XFS_mount_options="logbsize=256k"	 # for performance

# ------------------------------------------------
# Variables used by run-backup* and prune-drive* #
# ------------------------------------------------

# We append the drive name to this variable to get the mount point.
# If change this, change comment at top of "snapback mkfs" action.
# DON'T FORGET to add this directory to PRUNEPATHS in /etc/updatedb.conf !
readonly drive_dir_prefix=/backup/

# In case have mounted drives encrypted with old name (usually FS label).
readonly old_crypt_name_prefixes=

# Where send warning and error messages.
readonly sysadmin_email_addresses="sweikart@gmail.com"

# level 0: log when create *,00 snapshot; log # pruned & also # *.rm deleted
# level 1: log every backup (plus above)
# level 2: log the new snapshots that will be pruned (plus above)
# level 3: log the deleted snapshots (plus above); misses deletions before kill
declare -i -r log_level=0	     # verbosity of logs in /var/log/snapback/

# ----------------------------------

# How high can FileSystem usage get before warning $sysadmin_email_addresses?
# Also, if usage is too high, pruning takes priority over other actions.
declare -i -r min_FS_usage_percent=90	# for "df" and "df -i"

# Normally, backups run at higher priority and pruning runs at lower priority;
# but, if the min_FS_usage_percent is exceeded, those priorities are inverted
# (so, for this reason, it's safest to give 'copy' the lowest priority, so you
#  don't skip backups).
# A PID will be appended to these commands; if that's not adequate, then you'll
# need to define a function that takes a PID as its final argument, and assign
# that function (with optional initial arguments) to these variables.
readonly   cmd_to_set_copy_CPU_priority="renice +16 -p"
readonly  cmd_to_set_lower_CPU_priority="renice +15 -p"
readonly cmd_to_set_higher_CPU_priority="renice +13 -p"
#
readonly   cmd_to_set_copy_IO_priority="ionice -c 2 -n 7 -p"
readonly  cmd_to_set_lower_IO_priority="ionice -c 2 -n 6 -p"
readonly cmd_to_set_higher_IO_priority="ionice -c 2 -n 5 -p"

# ------------------------------------
# variables that control run-backup* #
# ------------------------------------

# The directories we back up, *must* be absolute paths; can use bash globbing.
	 dirs_to_backup="/"
drv_name2dirs_to_backup[Y]=/home/scott/{.bash*,bin,git} # personal memory stick
drv_name2dirs_to_backup[Z]=/var/tmp/small-dir # for testing with pseudo-drive Z

# Basic options for "rsync"; add --acls if it's supported.
# preallocate: slight ext4 speedup; hopefully works with --sparse
# preallocate error: rsync: do_fallocate <path> "Operation not supported (95)
readonly rsync_backup_opts="--archive --hard-links --xattrs --sparse --preallocate"

# See: https://stackoverflow.com/a/20738063 or "EXIT VALUES" in man page.
# Vanished source files (status=24) are common if backup tmp directories.
readonly successful_rsync_exit_statuses="0 24"
#
# We ignore SIGUSR1 or SIGINT (status=20) since partial snapshots are handled.
# Instead of logging failures for Too many links (status=31), speedup pruning.
readonly no_log_rsync_exit_statuses="20" # add 31 after address all issues

# If some drives are smaller and their filesystem usage gets too high, you can
# exclude directories rather than speed-up pruning; this is better than
# changing dirs_to_backup, because run-prune will delete $extra_excludes from
# older snapshots, freeing up space.
#
# NOTE: using this variable (or dirs_to_backup) has a big disadvantage: such
# drives can't be updated with bigger drives (e.g. after a drive was off-site):
# If you keep drives off-site, it's better to use a bigger backup_period
# or faster pruning for smaller drives, which still allows for updating.
#
# After you change this variable, touch excludes.txt to alert run-prune that
# a full exclude-style prune run is needed, so new excludes delete files.
#
# yumdb/ has inodes with 1K links: overwhelms ext*; OK with XFS/Btrfs/etc
readonly extra_excludes="/var/lib/yum/yumdb" # per-drive custom excludes

# Skip backups when there aren't many users, to avoid 'Too many links" problem.
readonly excluded_backup_hours="23 1 3"
#
# The number of hours (1, 2, 4, 8, 12, or 24) between cron-based backup runs.
# A backup is *always* done at midnight, since that's the one pruning keeps.
declare -i backup_period=1		# need much RAM for small period
  drv_name2backup_period[E]=4		# the E drive is 6x slower
  drv_name2backup_period[G]=24		# the G drive seems to be dieing
  drv_name2backup_period[Z]=2		# twice the period of the mk-Z output

# ----------------------------------------------------------------------------
# Variables that control prune-drives.  NOTE: backup_period, extra_excludes, #
#    and excluded_backup_hours (above) are also used in pruning.	     #
# ----------------------------------------------------------------------------

# Dirs that contain files with massive numbers of hard-links; don't
# need to set this if using a filesystem (like XFS) that supports a zillion
# hard-links per inode.
# Don't mark this 'readonly', we clear it if the backup drive has an
# FS which supports a zillion hard-links per inode.
hard_link_dirs="/var/repos/snap*" # for HRDAG's 'snapshot' command

# The following description of how pruning works is hard to follow.
# If you prefer examples, run the command "snapback test-prune",
# then 'cd' to ${drive_dir_prefix}Z (or however you renamed Z),
# then study the 'ls -CF -d .mk-Z.*' directories and files.  For example,
# .mk-Z.hour/ holds a few weeks of hourly snapshots, and
# .mk-Z.hour.pruned.ls holds the snapshots that were left after pruning.
#
# To grok how pruning works, you can trace the code in simulation mode:
#    snapback -d -T 5 prune-drives |& less
# and study the 'prune_drive' function.

# Skip 'span' days of the newest snapshots, rm half the older ones; repeat this
# loop until all the oldest snapshots are only *,00 (i.e. one per day),
# which encompasses 1.5 months for an hourly 'span' of 7 days.
declare -i days_per_span_for_hour_prune=4	# prune-drive* can change this
  drv_name2days_per_span_for_hour_prune[Z]=1	# for action test-prune
#
# At date where the previous rm's all but *,00, repeat algorithm for months,
# until all the oldest snapshots are only *-01,00 (i.e. one per month).
declare -i months_per_span_for_day_prune=4	# prune-drive* can change this
  drv_name2months_per_span_for_day_prune[Z]=1	# for action test-prune
#
# At date where the previous rm's all but *-01,00, repeat algorithm for years,
# until all the oldest snapshots are only *-01-01,00 (i.e. one per year).
declare -i years_per_span_for_month_prune=4	# prune-drive* can change
  drv_name2years_per_span_for_month_prune[Z]=1	# for action test-prune

# At date where previous rm's all but *-01-01,00, repeat algorithm for decades,
# until all the oldest snapshots are only ?0-01-01,00 (i.e. one per decade).
declare -i decades_per_span_for_year_prune=4	# prune-drive* can change
  drv_name2decades_per_span_for_year_prune[Z]=1	# for action test-prune

# You can use this variable to change all 4 of the previous variables at once,
# or to scale all 4 of the previous variables for a drive of a different size.
	 pruning_span_scale_factor=1.0	  # scales previous 4 variables
drv_name2pruning_span_scale_factor[G]=1.5 # G is 50% bigger than other drives
drv_name2pruning_span_scale_factor[Z]=1	  # Z used for pruning regression tests

# Action 'check-snapshot-hard-links' uses this optional list to find the
# first (and subsequent) snapshot that has a different inode for all
# of these files (and the action will make all these files immutable).
# Include files that should exist unchanged in every single snapshot.
# [Action 'check-snapshot-hard-links' shows the snapshots that can
#  be moved into .rm/ and then deleted, to be replaced by running
#  'update-drive' and rebuilding those snapshots (with correct hard links)
#  from another backup drive that had the missing snapshots.]
readonly very_old_immutable_files=

# --------------------------------------------------------------------------
# Naming policy (can be re-implemented with custom functions defined here) #
# --------------------------------------------------------------------------

# -----------------------------------
# to see the functions you can change, run: grep -A1 '^have_cmd \\$*' snapback
# -----------------------------------

# Set to 'T' for ISO standard, code will automagically rename snapshots.
# [Code is hard-wired to ',' ; email sweikart@gmail.com to implement variable.]
readonly snapshot_date_time_separator=','

# Default policy: drives are named as a single capitalized letter; you can
# usually set your own policy by simply changing *drive_name_regex= ,
# instead of defining your own 'set_drive_name' function in here.
#
# These regex variables are extended regular expressions; they're anchored when
# used ( e.g. ^$drive_name_regex$ ).
#
# Note that drive_name_regex is used by action 'list-drives' to generate the
# list of "all" drives for jobs whose std(in|out|err) is not a terminal
# (i.e. cron jobs and nohup jobs); admin_drive_name_regex is used when
# the sysadmin runs a command, or for the 'watch' action ('list-drives -a').
# So, when you want to do maintenance on a drive, so want to suspend
# backups and pruning, remove the drive's name from drive_name_regex= (only).
readonly       drive_name_regex='[AD]'
readonly admin_drive_name_regex='[A-Za-z]'
readonly is_drive_name_capitalized=$true

# -----------------------------------------------------------------------------

# if this doesn't work, use: M-x shell-script-mode
# Local Variables:
# mode: sh
# End:
